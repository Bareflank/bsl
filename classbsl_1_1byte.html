<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: bsl::byte Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebsl.html">bsl</a></li><li class="navelem"><a class="el" href="classbsl_1_1byte.html">byte</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classbsl_1_1byte-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bsl::byte Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>std::byte is a distinct type that implements the concept of byte as specified in the C++ language definition. Shift operations all require unsigned integer types, instead of any integer type.  
 <a href="classbsl_1_1byte.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="byte_8hpp_source.html">byte.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6745f2dfb9491ba81065f97fdf7143f3"><td class="memItemLeft" align="right" valign="top"><a id="a6745f2dfb9491ba81065f97fdf7143f3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a6745f2dfb9491ba81065f97fdf7143f3">value_type</a> = <a class="el" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a></td></tr>
<tr class="memdesc:a6745f2dfb9491ba81065f97fdf7143f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias for: T <br /></td></tr>
<tr class="separator:a6745f2dfb9491ba81065f97fdf7143f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a963e04e2e0ca1761c73eceb848f2add3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a963e04e2e0ca1761c73eceb848f2add3">byte</a> () noexcept=default</td></tr>
<tr class="memdesc:a963e04e2e0ca1761c73eceb848f2add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. This ensures the byte type is a POD type, allowing it to be constructed as a global resource. This is needed as aligned storage uses a <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> as its base type, and aligned storage is needed as a global resource to support the bsl::manager.  <a href="#a963e04e2e0ca1761c73eceb848f2add3">More...</a><br /></td></tr>
<tr class="separator:a963e04e2e0ca1761c73eceb848f2add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0a2a4b790d0db0e2a351cf0957d2a7"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#aba0a2a4b790d0db0e2a351cf0957d2a7">byte</a> (<a class="el" href="classbsl_1_1byte.html#a6745f2dfb9491ba81065f97fdf7143f3">value_type</a> const val) noexcept</td></tr>
<tr class="memdesc:aba0a2a4b790d0db0e2a351cf0957d2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> from a value_type.  <a href="#aba0a2a4b790d0db0e2a351cf0957d2a7">More...</a><br /></td></tr>
<tr class="separator:aba0a2a4b790d0db0e2a351cf0957d2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94febb57d5de43ab1b84d7202fd39e98"><td class="memTemplParams" colspan="2">template&lt;typename T  = value_type, enable_if_t&lt; is_integral&lt; T &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a94febb57d5de43ab1b84d7202fd39e98"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a> () const noexcept</td></tr>
<tr class="memdesc:a94febb57d5de43ab1b84d7202fd39e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> as a given integer type using a static_cast to perform the conversion.  <a href="#a94febb57d5de43ab1b84d7202fd39e98">More...</a><br /></td></tr>
<tr class="separator:a94febb57d5de43ab1b84d7202fd39e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0be3c62785ab9b577d97ca58234c77"><td class="memItemLeft" align="right" valign="top"><a id="aab0be3c62785ab9b577d97ca58234c77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#aab0be3c62785ab9b577d97ca58234c77">~byte</a> () noexcept=default</td></tr>
<tr class="memdesc:aab0be3c62785ab9b577d97ca58234c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroyes a previously created <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a>. <br /></td></tr>
<tr class="separator:aab0be3c62785ab9b577d97ca58234c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550b9647381361f524040db31afafb5c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a550b9647381361f524040db31afafb5c">byte</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;o) noexcept=default</td></tr>
<tr class="memdesc:a550b9647381361f524040db31afafb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a550b9647381361f524040db31afafb5c">More...</a><br /></td></tr>
<tr class="separator:a550b9647381361f524040db31afafb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9c3d91d3124239a847c5f55be8852"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a9ca9c3d91d3124239a847c5f55be8852">byte</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&amp;o) noexcept=default</td></tr>
<tr class="memdesc:a9ca9c3d91d3124239a847c5f55be8852"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="#a9ca9c3d91d3124239a847c5f55be8852">More...</a><br /></td></tr>
<tr class="separator:a9ca9c3d91d3124239a847c5f55be8852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dc91772c891c5752e15e5200f90420"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a91dc91772c891c5752e15e5200f90420">operator=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;o) &amp;noexcept=default</td></tr>
<tr class="memdesc:a91dc91772c891c5752e15e5200f90420"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment  <a href="#a91dc91772c891c5752e15e5200f90420">More...</a><br /></td></tr>
<tr class="separator:a91dc91772c891c5752e15e5200f90420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1227ecba57a87b313739291a9e77bc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a2e1227ecba57a87b313739291a9e77bc">operator=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&amp;o) &amp;noexcept=default</td></tr>
<tr class="memdesc:a2e1227ecba57a87b313739291a9e77bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment  <a href="#a2e1227ecba57a87b313739291a9e77bc">More...</a><br /></td></tr>
<tr class="separator:a2e1227ecba57a87b313739291a9e77bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8898c3de2dce4b8ecde478d321878ad3"><td class="memTemplParams" colspan="2">template&lt;typename O &gt; </td></tr>
<tr class="memitem:a8898c3de2dce4b8ecde478d321878ad3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a8898c3de2dce4b8ecde478d321878ad3">byte</a> (O val) noexcept=delete</td></tr>
<tr class="memdesc:a8898c3de2dce4b8ecde478d321878ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor allows for single argument constructors without the need to mark them as explicit as it will absorb any incoming potential implicit conversion and prevent it.  <a href="#a8898c3de2dce4b8ecde478d321878ad3">More...</a><br /></td></tr>
<tr class="separator:a8898c3de2dce4b8ecde478d321878ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab0219a10f69e1cf3b5b7e484f2d5c567"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#ab0219a10f69e1cf3b5b7e484f2d5c567">operator==</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab0219a10f69e1cf3b5b7e484f2d5c567"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as lhs.to_integer() == rhs.to_integer()  <a href="#ab0219a10f69e1cf3b5b7e484f2d5c567">More...</a><br /></td></tr>
<tr class="separator:ab0219a10f69e1cf3b5b7e484f2d5c567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f072f3699fff45d15d5fef3e82760d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#ac1f072f3699fff45d15d5fef3e82760d">operator!=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac1f072f3699fff45d15d5fef3e82760d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as !(lhs == rhs)  <a href="#ac1f072f3699fff45d15d5fef3e82760d">More...</a><br /></td></tr>
<tr class="separator:ac1f072f3699fff45d15d5fef3e82760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bc64f43546377a510b0198c5d64a5f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#aa9bc64f43546377a510b0198c5d64a5f">operator&lt;&lt;=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;b, <a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const shift) noexcept</td></tr>
<tr class="memdesc:aa9bc64f43546377a510b0198c5d64a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as b = byte{b.to_integer() &lt;&lt; shift}.  <a href="#aa9bc64f43546377a510b0198c5d64a5f">More...</a><br /></td></tr>
<tr class="separator:aa9bc64f43546377a510b0198c5d64a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1751fc9b990d53ac9121adb241521cb7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a1751fc9b990d53ac9121adb241521cb7">operator&gt;&gt;=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;b, <a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const shift) noexcept</td></tr>
<tr class="memdesc:a1751fc9b990d53ac9121adb241521cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as b = byte{b.to_integer() &gt;&gt; shift}.  <a href="#a1751fc9b990d53ac9121adb241521cb7">More...</a><br /></td></tr>
<tr class="separator:a1751fc9b990d53ac9121adb241521cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2addae39a9402a09b4ed0fb4f6c1fbe6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a2addae39a9402a09b4ed0fb4f6c1fbe6">operator&lt;&lt;</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;b, <a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const shift) noexcept</td></tr>
<tr class="memdesc:a2addae39a9402a09b4ed0fb4f6c1fbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as byte tmp{b}; tmp &lt;&lt;= shift;.  <a href="#a2addae39a9402a09b4ed0fb4f6c1fbe6">More...</a><br /></td></tr>
<tr class="separator:a2addae39a9402a09b4ed0fb4f6c1fbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539ea0124aa309c4ad877f87b81e0829"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a539ea0124aa309c4ad877f87b81e0829">operator&gt;&gt;</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;b, <a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const shift) noexcept</td></tr>
<tr class="memdesc:a539ea0124aa309c4ad877f87b81e0829"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as byte tmp{b}; tmp &gt;&gt;= shift;.  <a href="#a539ea0124aa309c4ad877f87b81e0829">More...</a><br /></td></tr>
<tr class="separator:a539ea0124aa309c4ad877f87b81e0829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f52c9bc6dd16ba1954a2096dea3283"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a86f52c9bc6dd16ba1954a2096dea3283">operator|=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a86f52c9bc6dd16ba1954a2096dea3283"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as lhs = byte{lhs.to_integer() | rhs.to_integer()};.  <a href="#a86f52c9bc6dd16ba1954a2096dea3283">More...</a><br /></td></tr>
<tr class="separator:a86f52c9bc6dd16ba1954a2096dea3283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac590e23654100a61ed9aa40688883e72"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#ac590e23654100a61ed9aa40688883e72">operator&amp;=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac590e23654100a61ed9aa40688883e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as lhs = byte{lhs.to_integer() &amp; rhs.to_integer()};.  <a href="#ac590e23654100a61ed9aa40688883e72">More...</a><br /></td></tr>
<tr class="separator:ac590e23654100a61ed9aa40688883e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1084a68002866020618e177ed0b2d6ab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a1084a68002866020618e177ed0b2d6ab">operator^=</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1084a68002866020618e177ed0b2d6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as lhs = byte{lhs.to_integer() ^ rhs.to_integer()};.  <a href="#a1084a68002866020618e177ed0b2d6ab">More...</a><br /></td></tr>
<tr class="separator:a1084a68002866020618e177ed0b2d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fce6c81d8c0e1b9816bf48c8e87a54"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a69fce6c81d8c0e1b9816bf48c8e87a54">operator|</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a69fce6c81d8c0e1b9816bf48c8e87a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as tmp{lhs}; tmp |= rhs;.  <a href="#a69fce6c81d8c0e1b9816bf48c8e87a54">More...</a><br /></td></tr>
<tr class="separator:a69fce6c81d8c0e1b9816bf48c8e87a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f90df6ead8bab35cda780bbc666f11"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a35f90df6ead8bab35cda780bbc666f11">operator &amp;</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a35f90df6ead8bab35cda780bbc666f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as tmp{lhs}; tmp &amp;= rhs;.  <a href="#a35f90df6ead8bab35cda780bbc666f11">More...</a><br /></td></tr>
<tr class="separator:a35f90df6ead8bab35cda780bbc666f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5e11298d1857d009eaaac63033d013"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#aec5e11298d1857d009eaaac63033d013">operator^</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;lhs, <a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aec5e11298d1857d009eaaac63033d013"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as tmp{lhs}; tmp ^= rhs;.  <a href="#aec5e11298d1857d009eaaac63033d013">More...</a><br /></td></tr>
<tr class="separator:aec5e11298d1857d009eaaac63033d013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efd75a5ead8952818369891ea21bce2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html#a0efd75a5ead8952818369891ea21bce2">operator~</a> (<a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;b) noexcept</td></tr>
<tr class="memdesc:a0efd75a5ead8952818369891ea21bce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as byte{~b.<a class="el" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98" title="Returns the bsl::byte as a given integer type using a static_cast to perform the conversion.">to_integer()</a>}.  <a href="#a0efd75a5ead8952818369891ea21bce2">More...</a><br /></td></tr>
<tr class="separator:a0efd75a5ead8952818369891ea21bce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>std::byte is a distinct type that implements the concept of byte as specified in the C++ language definition. Shift operations all require unsigned integer types, instead of any integer type. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_overview() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> mybyte{static_cast&lt;bsl::uint8&gt;(42)};</div><div class="line">        <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;byte: %d\n&quot;</span>, mybyte.to_integer());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a963e04e2e0ca1761c73eceb848f2add3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963e04e2e0ca1761c73eceb848f2add3">&#9670;&nbsp;</a></span>byte() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bsl::byte::byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. This ensures the byte type is a POD type, allowing it to be constructed as a global resource. This is needed as aligned storage uses a <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> as its base type, and aligned storage is needed as a global resource to support the bsl::manager. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_DEFAULT_CONSTRUCTOR_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_DEFAULT_CONSTRUCTOR_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_default_constructor() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> b{};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x10U};</div><div class="line"></div><div class="line">        b = <a class="code" href="classbsl_1_1byte.html">bsl::byte</a>{val};</div><div class="line">        <span class="keywordflow">if</span> (b.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aba0a2a4b790d0db0e2a351cf0957d2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0a2a4b790d0db0e2a351cf0957d2a7">&#9670;&nbsp;</a></span>byte() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bsl::byte::byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html#a6745f2dfb9491ba81065f97fdf7143f3">value_type</a> const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> from a value_type. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_BY_VALUE_CONSTRUCTOR_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_BY_VALUE_CONSTRUCTOR_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_by_value_constructor() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x10U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b{val};</div><div class="line">        <span class="keywordflow">if</span> (b.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>SUPPRESSION: PRQA 2180 - exception required</p><ul>
<li>We suppress this because A12-1-4 states that all constructors that are callable from a fundamental type should be marked as explicit. This is a fundamental type, but all implicit conversions are disabled through the use of the implicit general template constructor that is deleted which absorbs all incoming potential implicit conversions.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value of the integer to create the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a550b9647381361f524040db31afafb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550b9647381361f524040db31afafb5c">&#9670;&nbsp;</a></span>byte() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bsl::byte::byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ca9c3d91d3124239a847c5f55be8852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca9c3d91d3124239a847c5f55be8852">&#9670;&nbsp;</a></span>byte() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bsl::byte::byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8898c3de2dce4b8ecde478d321878ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8898c3de2dce4b8ecde478d321878ad3">&#9670;&nbsp;</a></span>byte() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename O &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bsl::byte::byte </td>
          <td>(</td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor allows for single argument constructors without the need to mark them as explicit as it will absorb any incoming potential implicit conversion and prevent it. </p>
<p>SUPPRESSION: PRQA 2180 - false positive</p><ul>
<li>We suppress this because A12-1-4 states that all constructors that are callable from a fundamental type should be marked as explicit. This is callable with a fundamental type, but it is marked as "delete" which means it does not apply.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">O</td><td>the type that could be implicitly converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value that could be implicitly converted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a94febb57d5de43ab1b84d7202fd39e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94febb57d5de43ab1b84d7202fd39e98">&#9670;&nbsp;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = value_type, enable_if_t&lt; is_integral&lt; T &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T bsl::byte::to_integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> as a given integer type using a static_cast to perform the conversion. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_TO_INTEGER_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_TO_INTEGER_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_to_integer() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x10U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b{val};</div><div class="line">        <span class="keywordflow">if</span> (b.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of integer to convert the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> as a given integer type using a static_cast to perform the conversion. </dd></dl>

</div>
</div>
<a id="a91dc91772c891c5752e15e5200f90420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dc91772c891c5752e15e5200f90420">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&amp; bsl::byte::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this </dd></dl>

</div>
</div>
<a id="a2e1227ecba57a87b313739291a9e77bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1227ecba57a87b313739291a9e77bc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a>&amp; bsl::byte::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assignment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object being moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab0219a10f69e1cf3b5b7e484f2d5c567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0219a10f69e1cf3b5b7e484f2d5c567">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as lhs.to_integer() == rhs.to_integer() </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_EQUAL_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_EQUAL_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_equal() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x10U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (b1 == b2) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the operator </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns lhs.to_integer() == rhs.to_integer() </dd></dl>

</div>
</div>
<a id="ac1f072f3699fff45d15d5fef3e82760d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f072f3699fff45d15d5fef3e82760d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as !(lhs == rhs) </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_NOT_EQUAL_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_NOT_EQUAL_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_not_equal() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (b1 != b2) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the operator </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns !(lhs == rhs) </dd></dl>

</div>
</div>
<a id="aa9bc64f43546377a510b0198c5d64a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bc64f43546377a510b0198c5d64a5f">&#9670;&nbsp;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp; operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as b = byte{b.to_integer() &lt;&lt; shift}. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_LSHIFT_ASSIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_LSHIFT_ASSIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_lshift_assign() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x01U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x02U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> b{val};</div><div class="line"></div><div class="line">        b &lt;&lt;= 1U;</div><div class="line">        <span class="keywordflow">if</span> (b.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> to shift </td></tr>
    <tr><td class="paramname">shift</td><td>the number of bits to shift b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a reference to the provided "b" </dd></dl>

</div>
</div>
<a id="a1751fc9b990d53ac9121adb241521cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1751fc9b990d53ac9121adb241521cb7">&#9670;&nbsp;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp; operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as b = byte{b.to_integer() &gt;&gt; shift}. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_RSHIFT_ASSIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_RSHIFT_ASSIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_rshift_assign() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x02U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x01U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> b{val};</div><div class="line"></div><div class="line">        b &gt;&gt;= 1U;</div><div class="line">        <span class="keywordflow">if</span> (b.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> to shift </td></tr>
    <tr><td class="paramname">shift</td><td>the number of bits to shift b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a reference to the provided "b" </dd></dl>

</div>
</div>
<a id="a2addae39a9402a09b4ed0fb4f6c1fbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2addae39a9402a09b4ed0fb4f6c1fbe6">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as byte tmp{b}; tmp &lt;&lt;= shift;. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_LSHIFT_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_LSHIFT_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_lshift() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x01U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x02U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b{val};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((b &lt;&lt; 1U).<a class="code" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a>() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> to shift </td></tr>
    <tr><td class="paramname">shift</td><td>the number of bits to shift b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns byte tmp{b}; tmp &lt;&lt;= shift; </dd></dl>

</div>
</div>
<a id="a539ea0124aa309c4ad877f87b81e0829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539ea0124aa309c4ad877f87b81e0829">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a> const&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as byte tmp{b}; tmp &gt;&gt;= shift;. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_RSHIFT_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_RSHIFT_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_rshift() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x02U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x01U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b{val};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((b &gt;&gt; 1U).<a class="code" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a>() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> to shift </td></tr>
    <tr><td class="paramname">shift</td><td>the number of bits to shift b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns byte tmp{b}; tmp &gt;&gt;= shift; </dd></dl>

</div>
</div>
<a id="a86f52c9bc6dd16ba1954a2096dea3283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f52c9bc6dd16ba1954a2096dea3283">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp; operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as lhs = byte{lhs.to_integer() | rhs.to_integer()};. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_OR_ASSIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_OR_ASSIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_or_assign() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x11U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        b1 |= b2;</div><div class="line">        <span class="keywordflow">if</span> (b1.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a reference to the provided "lhs" </dd></dl>

</div>
</div>
<a id="ac590e23654100a61ed9aa40688883e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac590e23654100a61ed9aa40688883e72">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp; operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as lhs = byte{lhs.to_integer() &amp; rhs.to_integer()};. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_AND_ASSIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_AND_ASSIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_and_assign() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x10U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        b1 &amp;= b2;</div><div class="line">        <span class="keywordflow">if</span> (b1.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a reference to the provided "lhs" </dd></dl>

</div>
</div>
<a id="a1084a68002866020618e177ed0b2d6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1084a68002866020618e177ed0b2d6ab">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> &amp; operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as lhs = byte{lhs.to_integer() ^ rhs.to_integer()};. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_XOR_ASSIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_XOR_ASSIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_xor_assign() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x01U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        b1 ^= b2;</div><div class="line">        <span class="keywordflow">if</span> (b1.to_integer() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a reference to the provided "lhs" </dd></dl>

</div>
</div>
<a id="a69fce6c81d8c0e1b9816bf48c8e87a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fce6c81d8c0e1b9816bf48c8e87a54">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as tmp{lhs}; tmp |= rhs;. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_OR_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_OR_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_or() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x11U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((b1 | b2).<a class="code" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a>() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns tmp{lhs}; tmp |= rhs; </dd></dl>

</div>
</div>
<a id="a35f90df6ead8bab35cda780bbc666f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f90df6ead8bab35cda780bbc666f11">&#9670;&nbsp;</a></span>operator &amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> operator &amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as tmp{lhs}; tmp &amp;= rhs;. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_AND_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_AND_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_and() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x10U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((b1 &amp; b2).<a class="code" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a>() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns tmp{lhs}; tmp &amp;= rhs; </dd></dl>

</div>
</div>
<a id="aec5e11298d1857d009eaaac63033d013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5e11298d1857d009eaaac63033d013">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as tmp{lhs}; tmp ^= rhs;. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_XOR_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_XOR_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_xor() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val1{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val2{0x11U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{0x01U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b1{val1};</div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b2{val2};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((b1 ^ b2).<a class="code" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a>() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns tmp{lhs}; tmp ^= rhs; </dd></dl>

</div>
</div>
<a id="a0efd75a5ead8952818369891ea21bce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efd75a5ead8952818369891ea21bce2">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1byte.html">byte</a> operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1byte.html">byte</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as byte{~b.<a class="el" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98" title="Returns the bsl::byte as a given integer type using a static_cast to perform the conversion.">to_integer()</a>}. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_BYTE_COMPLEMENT_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_BYTE_COMPLEMENT_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="print_8hpp.html">bsl/print.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="byte_8hpp.html">bsl/byte.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_byte_complement() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> val{0x10U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">bsl::uint8</a> expected{static_cast&lt;bsl::uint8&gt;(0xEF)};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1byte.html">bsl::byte</a> <span class="keyword">const</span> b{val};</div><div class="line">        <span class="keywordflow">if</span> ((~b).<a class="code" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98">to_integer</a>() == expected) {</div><div class="line">            <a class="code" href="namespacebsl.html#a88c46da64489ced5d04ef124d7ffbd70">bsl::print</a>(<span class="stringliteral">&quot;success\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the <a class="el" href="classbsl_1_1byte.html" title="std::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">bsl::byte</a> to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns byte{~b.<a class="el" href="classbsl_1_1byte.html#a94febb57d5de43ab1b84d7202fd39e98" title="Returns the bsl::byte as a given integer type using a static_cast to perform the conversion.">to_integer()</a>} </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/bsl/<a class="el" href="byte_8hpp_source.html">byte.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
