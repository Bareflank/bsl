<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: bsl::fmt&lt; V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebsl.html">bsl</a></li><li class="navelem"><a class="el" href="classbsl_1_1fmt.html">fmt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classbsl_1_1fmt-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bsl::fmt&lt; V &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> implements a similar syntax to that of std::format, We adopt a similar approach with some tweaks of course to ensure AUTOSAR compliance include:  
 <a href="classbsl_1_1fmt.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fmt_8hpp_source.html">fmt.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc90c0b33986d9dfc41a8f9cfa91d63f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#afc90c0b33986d9dfc41a8f9cfa91d63f">fmt</a> (<a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a> const &amp;ops, V const &amp;val) noexcept</td></tr>
<tr class="memdesc:afc90c0b33986d9dfc41a8f9cfa91d63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string.  <a href="#afc90c0b33986d9dfc41a8f9cfa91d63f">More...</a><br /></td></tr>
<tr class="separator:afc90c0b33986d9dfc41a8f9cfa91d63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df17d94afa00e98bce8afb9d9f9fb94"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#a2df17d94afa00e98bce8afb9d9f9fb94">fmt</a> (<a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a> const &amp;ops, V const &amp;val, <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> width) noexcept</td></tr>
<tr class="memdesc:a2df17d94afa00e98bce8afb9d9f9fb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string. Note that this version also accepts a dynamic width, meaning the width can be determined at runtime. If the width is provided, the width in the format string is ignored.  <a href="#a2df17d94afa00e98bce8afb9d9f9fb94">More...</a><br /></td></tr>
<tr class="separator:a2df17d94afa00e98bce8afb9d9f9fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf64d4ab93e76bdebc346b6e5c5ff2ac"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#aaf64d4ab93e76bdebc346b6e5c5ff2ac">fmt</a> (<a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const str, V const &amp;val) noexcept</td></tr>
<tr class="memdesc:aaf64d4ab93e76bdebc346b6e5c5ff2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string.  <a href="#aaf64d4ab93e76bdebc346b6e5c5ff2ac">More...</a><br /></td></tr>
<tr class="separator:aaf64d4ab93e76bdebc346b6e5c5ff2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bec32306808122527507f2d550929b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#a93bec32306808122527507f2d550929b">fmt</a> (<a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const str, V const &amp;val, <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const width) noexcept</td></tr>
<tr class="memdesc:a93bec32306808122527507f2d550929b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string. Note that this version also accepts a dynamic width, meaning the width can be determined at runtime. If the width is provided, the width in the format string is ignored.  <a href="#a93bec32306808122527507f2d550929b">More...</a><br /></td></tr>
<tr class="separator:a93bec32306808122527507f2d550929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ae1fb6f6a70dc1304a86d66318788ff68"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae1fb6f6a70dc1304a86d66318788ff68"><td class="memTemplItemLeft" align="right" valign="top">constexpr out&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#ae1fb6f6a70dc1304a86d66318788ff68">operator&lt;&lt;</a> (out&lt; T &gt; const o, <a class="el" href="classbsl_1_1fmt.html">fmt</a>&lt; U &gt; &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ae1fb6f6a70dc1304a86d66318788ff68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the provided formatted argument to the provided output type.  <a href="#ae1fb6f6a70dc1304a86d66318788ff68">More...</a><br /></td></tr>
<tr class="separator:ae1fb6f6a70dc1304a86d66318788ff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f080afb9de40f3a9709376dcbd3941"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af0f080afb9de40f3a9709376dcbd3941"><td class="memTemplItemLeft" align="right" valign="top">constexpr out&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#af0f080afb9de40f3a9709376dcbd3941">operator&lt;&lt;</a> (out&lt; T &gt; const o, <a class="el" href="classbsl_1_1fmt.html">fmt</a>&lt; U &gt; &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:af0f080afb9de40f3a9709376dcbd3941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the provided formatted argument to the provided output type. If you want to provide your own custom outputter, DO NOT overload this function. Instead, overload the fmt_impl function.  <a href="#af0f080afb9de40f3a9709376dcbd3941">More...</a><br /></td></tr>
<tr class="separator:af0f080afb9de40f3a9709376dcbd3941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32575fe89ce79d2ca53c0ceb8eb97491"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , enable_if_t&lt;!is_bool&lt; U &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_same&lt; U, char_type &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_pointer&lt; U &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_integral&lt; U &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_null_pointer&lt; U &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a32575fe89ce79d2ca53c0ceb8eb97491"><td class="memTemplItemLeft" align="right" valign="top">constexpr out&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html#a32575fe89ce79d2ca53c0ceb8eb97491">operator&lt;&lt;</a> (out&lt; T &gt; const o, U const &amp;arg) noexcept</td></tr>
<tr class="memdesc:a32575fe89ce79d2ca53c0ceb8eb97491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the provided argument to the provided output type. If you want to provide your own custom outputter, DO NOT overload this function. Instead, overload the fmt_impl function.  <a href="#a32575fe89ce79d2ca53c0ceb8eb97491">More...</a><br /></td></tr>
<tr class="separator:a32575fe89ce79d2ca53c0ceb8eb97491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename V&gt;<br />
class bsl::fmt&lt; V &gt;</h3>

<p>The <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> implements a similar syntax to that of std::format, We adopt a similar approach with some tweaks of course to ensure AUTOSAR compliance include: </p>
<ul>
<li>printf style syntax is not supported and instead we use the std::cout approach with &lt;&lt; operators, but using the std::format compressed syntax approach. This addresses most of the issues of both libraries. The std::cout &lt;&lt; approach ensures that the position of an argument is coupled with the argument itself, meaning there is no need to "verify" that the number of arguments or the position of an argument matches the format string, which is an issue with std::format. The rest of the std::cout library is horrible in almost every way. All of the formatters are global, and the syntax is obnoxiously verbose. The std::format syntax addresses both of these.</li>
<li>Since our approach uses &lt;&lt; instead of a printf style format string, there is no need for "{}" or ":" as positioning is handled by the code itself, so these are not included to further reduce the verbosity (although AUTOSAR requires that you use the full <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>{} syntax, so its a wash).</li>
<li>Octal is not supported as it is not supported by AUTOSAR.</li>
<li>Floating point is currently not supported, but that can be changed in the future if needed as that is not an AUTOSAR limitation, it was simply not required in the first iteration of this library. If you need floating point support, please contact us.</li>
<li>In our library, there is no difference between x/X and b/B. If you need this, and know what it means please contact us. This was mainly done because we prefer 0x with uppercase letters which is currently not an option with std::format.</li>
</ul>
<p><b>General Syntax:</b><br />
 </p><div class="fragment"><div class="line"><a class="code" href="namespacebsl.html#ac7462d3afecdac109000a17217ad2b63">fill</a>-and-align(optional) sign(optional) <span class="preprocessor">#(optional) 0(optional) width(optional) type(optional)</span></div></div><!-- fragment --><p>The sign, # and 0 options are only valid when an integer type is being formatted.</p>
<p><b>Rules for Optional Field [fill-and-align]:</b><br />
 The fill-and-align option tells <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> how to align the resulting output. The fill states what character should be used as padding (defaults to a space), and can be any character (except for '\0' which would result in UB). The align character determines the type of justification (either left, right or center). If the width field is missing, the fill-and-align field has no effect. In addition, if this field is combined with the '0' sign aware field, this field has no effect.</p><ul>
<li>'&lt;': Forces the field to be aligned to the start of the available space. This is the default for non-integer types</li>
<li>'&gt;': Forces the field to be aligned to the end of the available space. This is the default for integer types</li>
<li>'^': Forces the field to be centered within the available space. If the alignment results in an uneven number of fill characters, the right side of the alignment gets the extra fill character.</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_ALIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_ALIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_align() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&lt;10&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&gt;10&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;^10&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;10&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&gt;10&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.^10&quot;</span>, <span class="stringliteral">&quot;42&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;=&lt;30&quot;</span>, <span class="charliteral">&#39;=&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;-&lt;30&quot;</span>, <span class="charliteral">&#39;-&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;_&lt;30&quot;</span>, <span class="charliteral">&#39;_&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">42</div><div class="line">        42</div><div class="line">    42</div><div class="line">42........</div><div class="line">........42</div><div class="line">....42....</div><div class="line">==============================</div><div class="line">------------------------------</div><div class="line">______________________________</div></div><!-- fragment --><p><b>Rules for Optional Field [sign]:</b><br />
 The sign option states how an integer type should display its positive or negative sign.</p><ul>
<li>'+': Indicates that '+' is inserted for positive numbers while '-' is inserted for negative numbers.</li>
<li>'-': Indicates that only '-' is inserted for negative numbers</li>
<li>' ': Indicates that ' ' is inserted for positive numbers while '-' is inserted for negative numbers.</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_SIGN_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_SIGN_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_sign() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val1{42};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val2{-42};</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;+&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;+&quot;</span>, val2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;-&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;-&quot;</span>, val2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot; &quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot; &quot;</span>, val2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">+42</div><div class="line">-42</div><div class="line">42</div><div class="line">-42</div><div class="line"> 42</div><div class="line">-42</div></div><!-- fragment --><p><b>Rules for Optional Field [#]:</b><br />
 The # option enables the alternative form for integer types. If the type field is missing, this option is ignored.</p><ul>
<li>'s': ignored</li>
<li>'c': ignored</li>
<li>'b': Indicates that "0b" should be inserted for binary numbers</li>
<li>'B': Indicates that "0b" should be inserted for binary numbers</li>
<li>'d': ignored</li>
<li>'x': Indicates that "0x" should be inserted for hexidecimal numbers</li>
<li>'X': Indicates that "0x" should be inserted for hexidecimal numbers</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_ALT_FORM_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_ALT_FORM_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_alt_form() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#b&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#d&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#x&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">0b101010</div><div class="line">42</div><div class="line">0x2A</div></div><!-- fragment --><p><b>Rules for Optional Field [0]:</b><br />
 The 0 option enables the use of sign aware 0 padding. If this field is combined with the fill-and-align field, the fill-and-align field is ignored. The problem with fill-and-align is that if you want to, for example, output the hexidecimal number 0x2A as 0x002A, there is no way to do that with fill-and-align as the 0s would be on the wrong side of '0x'. Therefore, this option ignores fill-and-align and instead uses the width field to determine how many 0s to add to the output in the correct position within the output. Like fill-and-align, if the width field is missing, this option has no effect.</p><ul>
<li>'s': ignored</li>
<li>'c': ignored</li>
<li>'b': Inserts 0 to the right of sign and # and to the left of b</li>
<li>'B': Inserts 0 to the right of sign and # and to the left of B</li>
<li>'d': Inserts 0 to the right of sign and to the left of d</li>
<li>'x': Inserts 0 to the right of sign and # and to the left of x</li>
<li>'X': Inserts 0 to the right of sign and # and to the left of X</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_SIGN_AWARE_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_SIGN_AWARE_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_sign_aware() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#10b&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#10x&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#010b&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#010x&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">  0b101010</div><div class="line">      0x2A</div><div class="line">0b00101010</div><div class="line">0x0000002A</div></div><!-- fragment --><p><b>Rules for Optional Field [width]:</b><br />
 Unlike std::format, negative numbers are not supported. The width field determines the total length of the resulting output, with all options included. In addition, the <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> library supports dynamic width as well. If the dynamic width is provided, this field is ignored and the dynamic width is used instead.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_WIDTH_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_WIDTH_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_width() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> width{10U};</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&lt;10&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&gt;10&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;^10&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#010b&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#010x&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#0b&quot;</span>, val, width} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#0x&quot;</span>, val, width} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">42</div><div class="line">        42</div><div class="line">    42</div><div class="line">0b00101010</div><div class="line">0x0000002A</div><div class="line">0b00101010</div><div class="line">0x0000002A</div></div><!-- fragment --><p><b>type rules [bool]:</b><br />
 If <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>{} is given a boolean, the type field indicates the following:</p><ul>
<li>none, 's': outputs "true" or "false"</li>
<li>'b', 'B', 'c', 'd', 'x', 'X': outputs "1" or "0"</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_BOOL_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_BOOL_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_bool() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&quot;</span>, <span class="keyword">true</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;d&quot;</span>, <span class="keyword">true</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;d&quot;</span>, <span class="keyword">false</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line">1</div><div class="line">0</div></div><!-- fragment --><p><b>type rules [<a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9" title="Standard Char Type.">bsl::char_type</a>]:</b><br />
 If <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>{} is given a <a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9" title="Standard Char Type.">bsl::char_type</a>, the type field indicates the following:</p><ul>
<li>none, 's', 'c': outputs the ascii representation of the character</li>
<li>'b', 'B', 'd', 'x', 'X': uses static_cast&lt;bsl::uint8&gt;() to convert the character type and then uses the integral rules defined below.</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_CHAR_TYPE_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_CHAR_TYPE_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_char_type() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">char_type</a> val{<span class="charliteral">&#39;*&#39;</span>};</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;b&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;d&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;x&quot;</span>, val} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">*</div><div class="line">101010</div><div class="line">42</div><div class="line">2A</div></div><!-- fragment --><p><b>type rules [<a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208" title="C-style string type.">bsl::cstr_type</a>]:</b><br />
 If <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>{} is given a <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208" title="C-style string type.">bsl::cstr_type</a>, the type field indicates the following:</p><ul>
<li>none, 's': outputs string.</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_CSTR_TYPE_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_CSTR_TYPE_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_cstr_type() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;success&quot;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">success</div></div><!-- fragment --><p><b>type rules [integral]:</b><br />
 If <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>{} is given an integral type, the type field indicates the following:</p><ul>
<li>none, 'd': the number is outputted as a decimal.</li>
<li>'c': uses static_cast&lt;bsl::char_type&gt;() to convert the integral type and then uses the <a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9" title="Standard Char Type.">bsl::char_type</a> rules defined above.</li>
<li>'b': the number is outputted as a binary.</li>
<li>'B': the number is outputted as a binary.</li>
<li>'x': the number is outputted as a hexidecimal.</li>
<li>'X': the number is outputted as a hexidecimal.</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_INTREGRAL_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_INTREGRAL_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_integral() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val1{42};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val2{-42};</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;b&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;c&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;x&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#b&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#x&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#08b&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;#08x&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;+&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;+&quot;</span>, val2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;-&quot;</span>, val1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;-&quot;</span>, val2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Results in the following output: </p><div class="fragment"><div class="line">42</div><div class="line">101010</div><div class="line">*</div><div class="line">2A</div><div class="line"></div><div class="line">0b101010</div><div class="line">0x2A</div><div class="line"></div><div class="line">0b101010</div><div class="line">0x00002A</div><div class="line"></div><div class="line">+42</div><div class="line">-42</div><div class="line"></div><div class="line">42</div><div class="line">-42</div></div><!-- fragment --><p>For all other types, the BSL provides the "&lt;&lt;" syntax, but the use of <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> is not supported.</p>
<p>If you wish to implement support for your own types, you can do so why overloading the following function in the "bsl" namespace </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OUT&gt;</div><div class="line">constexpr <span class="keywordtype">void</span></div><div class="line">fmt_impl(OUT &amp;&amp;o, fmt_options <span class="keyword">const</span> &amp;ops, &lt;type&gt; <span class="keyword">const</span> &amp;val) noexcept</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>You can also overload the following if you wish to provide output support but do not wish to provide <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>{} support (this option will result in more efficient code): </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">[[maybe_unused]] constexpr out&lt;T&gt;</div><div class="line"><a class="code" href="classbsl_1_1fmt.html#ae1fb6f6a70dc1304a86d66318788ff68">operator&lt;&lt;</a>(out&lt;T&gt; <span class="keyword">const</span> o, &lt;type&gt; <span class="keyword">const</span> &amp;val) noexcept</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> constexpr (o.empty()) {</div><div class="line">        <span class="keywordflow">return</span> o;</div><div class="line">    }</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of value being formatted for output </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc90c0b33986d9dfc41a8f9cfa91d63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc90c0b33986d9dfc41a8f9cfa91d63f">&#9670;&nbsp;</a></span>fmt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1fmt.html">bsl::fmt</a>&lt; V &gt;::<a class="el" href="classbsl_1_1fmt.html">fmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a> const &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_CONSTRUCTOR_F_VAL_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_CONSTRUCTOR_F_VAL_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_constructor_f_val() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;23&quot;</span>, <span class="charliteral">&#39;.&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;42&quot;</span>, <span class="charliteral">&#39;.&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>the format options used to format the output of val </td></tr>
    <tr><td class="paramname">val</td><td>the value to output given the provided format string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2df17d94afa00e98bce8afb9d9f9fb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df17d94afa00e98bce8afb9d9f9fb94">&#9670;&nbsp;</a></span>fmt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1fmt.html">bsl::fmt</a>&lt; V &gt;::<a class="el" href="classbsl_1_1fmt.html">fmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a> const &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string. Note that this version also accepts a dynamic width, meaning the width can be determined at runtime. If the width is provided, the width in the format string is ignored. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_CONSTRUCTOR_F_VAL_WIDTH_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_CONSTRUCTOR_F_VAL_WIDTH_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_constructor_f_val_width() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> width1{23U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> width2{42U};</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;&quot;</span>, <span class="charliteral">&#39;.&#39;</span>, width1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;&quot;</span>, <span class="charliteral">&#39;.&#39;</span>, width2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>the format options used to format the output of val </td></tr>
    <tr><td class="paramname">val</td><td>the value to output given the provided format string </td></tr>
    <tr><td class="paramname">width</td><td>a dynamic width which overrides the width field in the format string (used to set the width field at runtime). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf64d4ab93e76bdebc346b6e5c5ff2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf64d4ab93e76bdebc346b6e5c5ff2ac">&#9670;&nbsp;</a></span>fmt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1fmt.html">bsl::fmt</a>&lt; V &gt;::<a class="el" href="classbsl_1_1fmt.html">fmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_CONSTRUCTOR_F_VAL_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_CONSTRUCTOR_F_VAL_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_constructor_f_val() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;23&quot;</span>, <span class="charliteral">&#39;.&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;42&quot;</span>, <span class="charliteral">&#39;.&#39;</span>} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the format options used to format the output of val </td></tr>
    <tr><td class="paramname">val</td><td>the value to output given the provided format string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93bec32306808122527507f2d550929b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bec32306808122527507f2d550929b">&#9670;&nbsp;</a></span>fmt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1fmt.html">bsl::fmt</a>&lt; V &gt;::<a class="el" href="classbsl_1_1fmt.html">fmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a>, which when passed to an outputter will output the provided value given the provided format string. Note that this version also accepts a dynamic width, meaning the width can be determined at runtime. If the width is provided, the width in the format string is ignored. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FMT_CONSTRUCTOR_F_VAL_WIDTH_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FMT_CONSTRUCTOR_F_VAL_WIDTH_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fmt_constructor_f_val_width() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> width1{23U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> width2{42U};</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;&quot;</span>, <span class="charliteral">&#39;.&#39;</span>, width1} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="classbsl_1_1fmt.html">bsl::fmt</a>{<span class="stringliteral">&quot;.&lt;&quot;</span>, <span class="charliteral">&#39;.&#39;</span>, width2} &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the format options used to format the output of val </td></tr>
    <tr><td class="paramname">val</td><td>the value to output given the provided format string </td></tr>
    <tr><td class="paramname">width</td><td>a dynamic width which overrides the width field in the format string (used to set the width field at runtime). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae1fb6f6a70dc1304a86d66318788ff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fb6f6a70dc1304a86d66318788ff68">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr out&lt;T&gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">out&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1fmt.html">fmt</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the provided formatted argument to the provided output type. </p>
<dl class="section note"><dt>Note</dt><dd>We make this a friend of <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> as there is no way to define a stream operator as a member function. As a result, this would require the use of a public member function that would expose the const&amp;, potentially leading to UB.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of outputter provided </td></tr>
    <tr><td class="paramname">U</td><td>the type of value being ouputter using <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the instance of the outputter used to output the value. </td></tr>
    <tr><td class="paramname">arg</td><td>a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> that contains the value being outputted as well as any format instructions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return o </dd></dl>

</div>
</div>
<a id="af0f080afb9de40f3a9709376dcbd3941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f080afb9de40f3a9709376dcbd3941">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr out&lt; T &gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">out&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1fmt.html">fmt</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the provided formatted argument to the provided output type. If you want to provide your own custom outputter, DO NOT overload this function. Instead, overload the fmt_impl function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of outputter provided </td></tr>
    <tr><td class="paramname">U</td><td>the type of value being ouputter using <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the instance of the outputter used to output the value. </td></tr>
    <tr><td class="paramname">arg</td><td>a <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> that contains the value being outputted as well as any format instructions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return o </dd></dl>

</div>
</div>
<a id="a32575fe89ce79d2ca53c0ceb8eb97491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32575fe89ce79d2ca53c0ceb8eb97491">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , enable_if_t&lt;!is_bool&lt; U &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_same&lt; U, char_type &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_pointer&lt; U &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_integral&lt; U &gt;::value, bool &gt;  = true, enable_if_t&lt;!is_null_pointer&lt; U &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr out&lt; T &gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">out&lt; T &gt; const&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the provided argument to the provided output type. If you want to provide your own custom outputter, DO NOT overload this function. Instead, overload the fmt_impl function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of outputter provided </td></tr>
    <tr><td class="paramname">U</td><td>the type of value being ouputter using <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the instance of the outputter used to output the value. </td></tr>
    <tr><td class="paramname">arg</td><td>the value to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return o </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/bsl/<a class="el" href="fmt_8hpp_source.html">fmt.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
