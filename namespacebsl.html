<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: bsl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bsl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__const.html">add_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that a topmost const qualifier is added.  <a href="structbsl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that a topmost lvalue reference is added.  <a href="structbsl_1_1add__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that a topmost pointer is added.  <a href="structbsl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that a topmost rvalue reference is added.  <a href="structbsl_1_1add__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that a topmost volatile qualifier is added.  <a href="structbsl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the std::aligned_storage interface. The only real difference is we use "m_data" instead of "data" to represent the member variable name.  <a href="structbsl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1aligned__union.html">aligned_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the std::aligned_union interface. The only real difference is we use "m_data" instead of "data" to represent the member variable name.  <a href="structbsl_1_1aligned__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1alignment__of.html">alignment_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant value equal to the alignment of T.  <a href="structbsl_1_1alignment__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1arguments.html">arguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the argc, argv arguments that are passed to traditional C applications using a <a class="el" href="classbsl_1_1span.html" title="A bsl::span is a non-owning view of an array type. Unlike a bsl::array, the bsl::span does not own th...">bsl::span</a>.  <a href="classbsl_1_1arguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a safe encapsulation for a C-style array, minicing the std::array APIs. This container is an aggregate type, but unlike a std::array, a <a class="el" href="classbsl_1_1array.html" title="Provides a safe encapsulation for a C-style array, minicing the std::array APIs. This container is an...">bsl::array</a> does not provide the T[n] syntax as this is nither Core Guideline compliant or compliant with AUTOSAR. Instead we provide <a class="el" href="classbsl_1_1array.html#ab2f77bf585ce05253693930ec2a3c1d3" title="Returns a pointer to the instance of T stored at index &quot;index&quot;. If the index is out of bounds,...">at_if()</a> versions which return a pointer to the element being requested. If the element does not exist, a nullptr is returned, providing a means to check for logic errors without the need for exceptions or failing fast which is not compliant with AUTOSAR. We also do not support N==0 type arrays and like other BSL classes, we do not support the member version of <a class="el" href="namespacebsl.html#ace538312ab16b685cfffc7eb75a1eb6a" title="Swaps the given values.">swap()</a> and <a class="el" href="namespacebsl.html#ac7462d3afecdac109000a17217ad2b63" title="Sets all elements of a view to &quot;value&quot;. T must be copy assignable.">fill()</a> as they are not compliant with AUTOSAR (due to the name reuse). User <a class="el" href="namespacebsl.html#ace538312ab16b685cfffc7eb75a1eb6a" title="Swaps the given values.">bsl::swap()</a> and <a class="el" href="namespacebsl.html#ac7462d3afecdac109000a17217ad2b63" title="Sets all elements of a view to &quot;value&quot;. T must be copy assignable.">bsl::fill()</a> instead.  <a href="classbsl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an error code. We do not use the same pattern as the standard library. The goal is to ensure an error code can consume a single register to ensure maximum compatibility with different CPU archiectures that only have a 32bit return register. We also do not use an enum to ensure custom error codes can be created. This also means there are no error code categories. Instead, an error code is checked if it is negative, and unchecked if it is positive to align with AUTOSAR. Finally, we provide the ability to change the type that an error code uses under the hood which allows you to use a "long" type, or some other integer type depending on your requirements (i.e., NTSTATUS).  <a href="classbsl_1_1basic__errc__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classbsl_1_1basic__string__view.html" title="A bsl::basic_string_view is a non-owning, encapsulation of a string, providing helper functions for w...">bsl::basic_string_view</a> is a non-owning, encapsulation of a string, providing helper functions for working with strings.  <a href="classbsl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1byte.html">byte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::byte is a distinct type that implements the concept of byte as specified in the C++ language definition. Shift operations all require unsigned integer types, instead of any integer type.  <a href="classbsl_1_1byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1char__traits_3_01char__type_01_4.html">char_traits&lt; char_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the char_traits for the type "char_type", which is a type alias for "char". In general, you should not need to use this class directly, and we only provide it for compatibility. Note that there are some BSL specific changes to the library, which should not change the "valid" behavior of this class, but will change "invalid" behavior to comply better with AUTOSAR. Also, we do not provide support for the type aliases (due to name collisions), and there are some functions that we do not support as they are not really AUTOSAR compliant (requiring the use of C-style array types). Once again, do not use this directly. Instead, find a BSL alternative to this functionality.  <a href="classbsl_1_1char__traits_3_01char__type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1common__type.html">common_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the type that is common between all provided types. For more information, please see std::common_type.  <a href="structbsl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T if B is true, otherwise is the same as F.  <a href="structbsl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.  <a href="classbsl_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1contiguous__iterator.html">contiguous_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a contiguous iterator as defined by the C++ specification, with the follwing differences:  <a href="classbsl_1_1contiguous__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.  <a href="structbsl_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.  <a href="classbsl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a conditional "if" statement for SFINAE overload resolution. If B is true, <a class="el" href="structbsl_1_1enable__if.html" title="Defines a conditional &quot;if&quot; statement for SFINAE overload resolution. If B is true,...">bsl::enable_if</a> has a public member typedef of type T, otherwise, there is no public member typedef.  <a href="structbsl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, std::rank&lt;T&gt;::value). For any other type, or if T is an array of unknown bound along its first dimension and N is 0, value is 0.  <a href="classbsl_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt.html">fmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> implements a similar syntax to that of std::format, We adopt a similar approach with some tweaks of course to ensure AUTOSAR compliance include:  <a href="classbsl_1_1fmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by fmt to determine how to format the output of an fmt command. See the documentation fo <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for more information.  <a href="classbsl_1_1fmt__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1has__unique__object__representations.html">has_unique_object_representations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a class type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1has__unique__object__representations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1has__virtual__destructor.html">has_virtual_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a class type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1has__virtual__destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacebsl.html#ae64eadc3e172cb807384a588706002eb" title="reduces the verbosity of bsl::in_place_t">bsl::in_place</a>, bsl::in_place_type, and bsl::in_place_index are disambiguation tags that can be passed to the constructors of classes like bls::result to indicate that the contained object should be constructed in-place. In addition, bsl::in_place_type and bsl::in_place_index provide type and indiex information as well.  <a href="classbsl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacebsl.html#ae64eadc3e172cb807384a588706002eb" title="reduces the verbosity of bsl::in_place_t">bsl::in_place</a>, bsl::in_place_type, and bsl::in_place_index are disambiguation tags that can be passed to the constructors of classes like bls::result to indicate that the contained object should be constructed in-place. In addition, bsl::in_place_type and bsl::in_place_index provide type and indiex information as well.  <a href="classbsl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacebsl.html#ae64eadc3e172cb807384a588706002eb" title="reduces the verbosity of bsl::in_place_t">bsl::in_place</a>, bsl::in_place_type, and bsl::in_place_index are disambiguation tags that can be passed to the constructors of classes like bls::result to indicate that the contained object should be constructed in-place. In addition, bsl::in_place_type and bsl::in_place_index provide type and indiex information as well.  <a href="classbsl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template std::integer_sequence represents a compile-time sequence of integers. When used as an argument to a function template, the parameter pack Ints can be deduced and used in pack expansion.  <a href="classbsl_1_1integer__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an array type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1integral__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the result of calling <a class="el" href="namespacebsl.html#a6417bf1714ada612ce525074e8fab216" title="Invokes the callable object &quot;f&quot; with arguments &quot;tn&quot;.">bsl::invoke&lt;F, ARGS...&gt;</a> if the provided template arguments are valid.  <a href="classbsl_1_1invoke__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__abstract.html">is_abstract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an abstract class type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__aggregate.html">is_aggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an aggregate type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__aggregate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an abstract class type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an array type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__assignable.html">is_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__base__of.html">is_base_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type T is a base of type U, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__bool.html">is_bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a bool type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__bounded__array.html">is_bounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an bounded array, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__bounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__class.html">is_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a class type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__compound.html">is_compound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a compound type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__const.html">is_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is qualified as const, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__constructible.html">is_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is convertible from "From" to "To", provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__copy__assignable.html">is_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is copy assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__copy__constructible.html">is_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is copy constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__copyable.html">is_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is copy assignable and constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is default constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is destructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is empty, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an enum type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is marked final, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a floating point type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__function.html">is_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a function type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a fundamental type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__fundamental.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an integral type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided args form a callable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__invocable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided args form a callable, and is convertible to "R", provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__invocable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an lvalue reference type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a member function pointer type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a member object pointer type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a member pointer type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__movable.html">is_movable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is move assignable and constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__movable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__move__assignable.html">is_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is move assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__move__constructible.html">is_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is move constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is convertible from "From" to "To", provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow copy assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow copy constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__copyable.html">is_nothrow_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow copy assignable and constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow default constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow destructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__invocable.html">is_nothrow_invocable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided args form a nothrow callable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__invocable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__invocable__r.html">is_nothrow_invocable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided args form a nothrow callable, and is convertible to "R" (without throwing), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__invocable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__movable.html">is_nothrow_movable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow move assignable and constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__movable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow move assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is nothrow move constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type T is nothrow swappable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type T and U are nothrow swappable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__nothrow__swappable__with.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a nullptr type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__null__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__object.html">is_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an object type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__pod.html">is_pod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a POD type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__pod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a pointer type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a POD type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__polymorphic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__reference.html">is_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a reference type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__reference__wrapper.html">is_reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a <a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__reference__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an rvalue reference type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided types are the same, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a scalar type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a signed type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__standard__layout.html">is_standard_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a standard layout type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__standard__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__swappable.html">is_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type T is swappable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__swappable__with.html">is_swappable_with</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type T and U are nothrow swappable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__swappable__with.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivial.html">is_trivial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a trivial type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__assignable.html">is_trivially_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__constructible.html">is_trivially_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivally copy assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially copy constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially copyable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially default constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__destructible.html">is_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially destructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__movable.html">is_trivially_movable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially movable, provides the member constant value equal to true. Otherwise the member constant value is false. Note that this is the same thing as <a class="el" href="classbsl_1_1is__trivially__copyable.html" title="If the provided type is trivially copyable, provides the member constant value equal to true....">bsl::is_trivially_copyable</a>.  <a href="classbsl_1_1is__trivially__movable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially move assignable, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is trivially move constructible, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__unbounded__array.html">is_unbounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an unbounded array, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__unbounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__union.html">is_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a union type, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a unsigned type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is a void type (taking into account const qualifications), provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is qualified as volatile, provides the member constant value equal to true. Otherwise the member constant value is false.  <a href="classbsl_1_1is__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1make__signed.html">make_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an unsigned type (taking into account const qualifications), Provides the member typedef type which is the same as T, except that the type is signed.  <a href="structbsl_1_1make__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the provided type is an signed type (taking into account const qualifications), Provides the member typedef type which is the same as T, except that the type is unsigned.  <a href="structbsl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical negation of the type trait B, effectively performing a logical NOT on the trait.  <a href="classbsl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1nonesuch.html">nonesuch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by is_detected to indicate detection failure.  <a href="classbsl_1_1nonesuch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements std::numeric_limits.  <a href="classbsl_1_1numeric__limits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0.  <a href="classbsl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classbsl_1_1reference__wrapper.html" title="reference_wrapper prototype">reference_wrapper</a> prototype  <a href="classbsl_1_1reference__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__all__extents.html">remove_all_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost extent is removed.  <a href="structbsl_1_1remove__all__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost const qualifier is removed.  <a href="structbsl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost const and volatile qualifiers are removed.  <a href="structbsl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__cvext.html">remove_cvext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost const, volatile and extent qualifiers are removed.  <a href="structbsl_1_1remove__cvext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost const, volatile and reference qualifiers are removed.  <a href="structbsl_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__extent.html">remove_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost extent is removed.  <a href="structbsl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost pointer is removed.  <a href="structbsl_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost reference is removed.  <a href="structbsl_1_1remove__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost volatile qualifier is removed.  <a href="structbsl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1result.html">result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to return T or E from a function, ensuring that T is only created if an error is not present.  <a href="classbsl_1_1result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reverse iterator as defined by the C++ specification, with the follwing differences:  <a href="classbsl_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classbsl_1_1source__location.html" title="This class implements the source_location specification that will eventually be included in C++20....">source_location</a> specification that will eventually be included in C++20. We make some changes to the specification to support AUTOSAR, but these changes should not change how the code is compiled or used, with the exception that we do not include the column() as this does not seem to be implemented by any compilers yet.  <a href="classbsl_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classbsl_1_1span.html" title="A bsl::span is a non-owning view of an array type. Unlike a bsl::array, the bsl::span does not own th...">bsl::span</a> is a non-owning view of an array type. Unlike a <a class="el" href="classbsl_1_1array.html" title="Provides a safe encapsulation for a C-style array, minicing the std::array APIs. This container is an...">bsl::array</a>, the <a class="el" href="classbsl_1_1span.html" title="A bsl::span is a non-owning view of an array type. Unlike a bsl::array, the bsl::span does not own th...">bsl::span</a> does not own the memory it accesses and therefore cannot outlive whatever array you give it. The <a class="el" href="classbsl_1_1span.html" title="A bsl::span is a non-owning view of an array type. Unlike a bsl::array, the bsl::span does not own th...">bsl::span</a> is also very similar to a gsl::span and a std::span with some key differences.  <a href="classbsl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef "type" that names T (i.e., the identity transformation).  <a href="structbsl_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1underlying__type.html">underlying_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a complete enumeration type, provides a member typedef type that names the underlying type of T.  <a href="structbsl_1_1underlying__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1ut__given.html">ut_given</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the initial state of a unit test scenario including the creation of any objects that might participate in the unit test.  <a href="classbsl_1_1ut__given.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1ut__scenario.html">ut_scenario</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a unit test scenario. A scenario defines a user story, describing the "scenario" being tested. A scenario should be paired with <a class="el" href="classbsl_1_1ut__given.html" title="Defines the initial state of a unit test scenario including the creation of any objects that might pa...">ut_given</a>, <a class="el" href="classbsl_1_1ut__when.html" title="Defines the &quot;action&quot; of a unit test scenario.">ut_when</a> and <a class="el" href="classbsl_1_1ut__then.html" title="Defines the expected &quot;result&quot; of a unit test scenario.">ut_then</a> to define the scenario in english.  <a href="classbsl_1_1ut__scenario.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1ut__then.html">ut_then</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the expected "result" of a unit test scenario.  <a href="classbsl_1_1ut__then.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1ut__when.html">ut_when</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the "action" of a unit test scenario.  <a href="classbsl_1_1ut__when.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1a151f8f27c4d3e44230d246481ffd29"><td class="memTemplParams" colspan="2"><a id="a1a151f8f27c4d3e44230d246481ffd29"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a151f8f27c4d3e44230d246481ffd29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1a151f8f27c4d3e44230d246481ffd29">add_const_t</a> = typename <a class="el" href="structbsl_1_1add__const.html">add_const</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a1a151f8f27c4d3e44230d246481ffd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1add__const.html" title="Provides the member typedef type which is the same as T, except that a topmost const qualifier is add...">bsl::add_const</a> <br /></td></tr>
<tr class="separator:a1a151f8f27c4d3e44230d246481ffd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd6ef69672c27edcb4dfbe60386ebc6"><td class="memTemplParams" colspan="2"><a id="a8fd6ef69672c27edcb4dfbe60386ebc6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fd6ef69672c27edcb4dfbe60386ebc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a8fd6ef69672c27edcb4dfbe60386ebc6">add_lvalue_reference_t</a> = typename <a class="el" href="structbsl_1_1add__lvalue__reference.html">add_lvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a8fd6ef69672c27edcb4dfbe60386ebc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1add__lvalue__reference.html" title="Provides the member typedef type which is the same as T, except that a topmost lvalue reference is ad...">bsl::add_lvalue_reference</a> <br /></td></tr>
<tr class="separator:a8fd6ef69672c27edcb4dfbe60386ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c24eb7568bc5fdad33ac28a2bea77"><td class="memTemplParams" colspan="2"><a id="a063c24eb7568bc5fdad33ac28a2bea77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a063c24eb7568bc5fdad33ac28a2bea77"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a063c24eb7568bc5fdad33ac28a2bea77">add_pointer_t</a> = typename <a class="el" href="structbsl_1_1add__pointer.html">add_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a063c24eb7568bc5fdad33ac28a2bea77"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1add__pointer.html" title="Provides the member typedef type which is the same as T, except that a topmost pointer is added.">bsl::add_pointer</a> <br /></td></tr>
<tr class="separator:a063c24eb7568bc5fdad33ac28a2bea77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624d5ced1c693a5b7c74ac08f6a277b7"><td class="memTemplParams" colspan="2"><a id="a624d5ced1c693a5b7c74ac08f6a277b7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a624d5ced1c693a5b7c74ac08f6a277b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a624d5ced1c693a5b7c74ac08f6a277b7">add_rvalue_reference_t</a> = typename <a class="el" href="structbsl_1_1add__rvalue__reference.html">add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a624d5ced1c693a5b7c74ac08f6a277b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1add__rvalue__reference.html" title="Provides the member typedef type which is the same as T, except that a topmost rvalue reference is ad...">bsl::add_rvalue_reference</a> <br /></td></tr>
<tr class="separator:a624d5ced1c693a5b7c74ac08f6a277b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2220898fa037da5c0b91fbac7013d895"><td class="memTemplParams" colspan="2"><a id="a2220898fa037da5c0b91fbac7013d895"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2220898fa037da5c0b91fbac7013d895"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2220898fa037da5c0b91fbac7013d895">add_volatile_t</a> = typename <a class="el" href="structbsl_1_1add__volatile.html">add_volatile</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a2220898fa037da5c0b91fbac7013d895"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1add__volatile.html" title="Provides the member typedef type which is the same as T, except that a topmost volatile qualifier is ...">bsl::add_volatile</a> <br /></td></tr>
<tr class="separator:a2220898fa037da5c0b91fbac7013d895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82d34d29d79ef9f6e52e634bd8d393c"><td class="memTemplParams" colspan="2"><a id="ac82d34d29d79ef9f6e52e634bd8d393c"></a>
template&lt;bsl::uintmax N, bsl::uintmax A = 0&gt; </td></tr>
<tr class="memitem:ac82d34d29d79ef9f6e52e634bd8d393c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac82d34d29d79ef9f6e52e634bd8d393c">aligned_storage_t</a> = typename <a class="el" href="structbsl_1_1aligned__storage.html">aligned_storage</a>&lt; void, N, A &gt;::type</td></tr>
<tr class="memdesc:ac82d34d29d79ef9f6e52e634bd8d393c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1aligned__storage.html" title="Implements the std::aligned_storage interface. The only real difference is we use &quot;m_data&quot; instead of...">bsl::aligned_storage</a> <br /></td></tr>
<tr class="separator:ac82d34d29d79ef9f6e52e634bd8d393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eddfae4535746532a3a4b68c81e0f60"><td class="memTemplParams" colspan="2"><a id="a0eddfae4535746532a3a4b68c81e0f60"></a>
template&lt;bsl::uintmax LEN, typename... TYPES&gt; </td></tr>
<tr class="memitem:a0eddfae4535746532a3a4b68c81e0f60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0eddfae4535746532a3a4b68c81e0f60">aligned_union_t</a> = typename <a class="el" href="structbsl_1_1aligned__union.html">aligned_union</a>&lt; void, LEN, TYPES... &gt;::type</td></tr>
<tr class="memdesc:a0eddfae4535746532a3a4b68c81e0f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1aligned__union.html" title="Implements the std::aligned_union interface. The only real difference is we use &quot;m_data&quot; instead of &quot;...">bsl::aligned_union</a> <br /></td></tr>
<tr class="separator:a0eddfae4535746532a3a4b68c81e0f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab545b3015440be59ef0bf70ddc3a45a"><td class="memTemplParams" colspan="2"><a id="aab545b3015440be59ef0bf70ddc3a45a"></a>
template&lt;bool B&gt; </td></tr>
<tr class="memitem:aab545b3015440be59ef0bf70ddc3a45a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aab545b3015440be59ef0bf70ddc3a45a">bool_constant</a> = <a class="el" href="classbsl_1_1integral__constant.html">integral_constant</a>&lt; bool, B &gt;</td></tr>
<tr class="memdesc:aab545b3015440be59ef0bf70ddc3a45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides the boolean version of an integral constant <br /></td></tr>
<tr class="separator:aab545b3015440be59ef0bf70ddc3a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd32c87c9060b301047deb71f5b775e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">char_type</a> = char</td></tr>
<tr class="memdesc:acd32c87c9060b301047deb71f5b775e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard Char Type.  <a href="#acd32c87c9060b301047deb71f5b775e9">More...</a><br /></td></tr>
<tr class="separator:acd32c87c9060b301047deb71f5b775e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9df722b533e5fe295751201cfabe2c"><td class="memTemplParams" colspan="2"><a id="a8e9df722b533e5fe295751201cfabe2c"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a8e9df722b533e5fe295751201cfabe2c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a8e9df722b533e5fe295751201cfabe2c">common_type_t</a> = typename <a class="el" href="structbsl_1_1common__type.html">common_type</a>&lt; T... &gt;::type</td></tr>
<tr class="memdesc:a8e9df722b533e5fe295751201cfabe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1common__type.html" title="Provides the member typedef type which is the type that is common between all provided types....">bsl::common_type</a> <br /></td></tr>
<tr class="separator:a8e9df722b533e5fe295751201cfabe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1cc2f9cd1ea0202b54f4237ecd1e66"><td class="memTemplParams" colspan="2"><a id="a4f1cc2f9cd1ea0202b54f4237ecd1e66"></a>
template&lt;bool B, typename T , typename F &gt; </td></tr>
<tr class="memitem:a4f1cc2f9cd1ea0202b54f4237ecd1e66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4f1cc2f9cd1ea0202b54f4237ecd1e66">conditional_t</a> = typename <a class="el" href="structbsl_1_1conditional.html">conditional</a>&lt; B, T, F &gt;::type</td></tr>
<tr class="memdesc:a4f1cc2f9cd1ea0202b54f4237ecd1e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1conditional.html" title="Provides the member typedef type which is the same as T if B is true, otherwise is the same as F.">bsl::conditional</a> <br /></td></tr>
<tr class="separator:a4f1cc2f9cd1ea0202b54f4237ecd1e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed5ddeb69e264299ece03325135e3a"><td class="memItemLeft" align="right" valign="top"><a id="adbed5ddeb69e264299ece03325135e3a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#adbed5ddeb69e264299ece03325135e3a">nullptr_t</a> = decltype(nullptr)</td></tr>
<tr class="memdesc:adbed5ddeb69e264299ece03325135e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a nullptr type <br /></td></tr>
<tr class="separator:adbed5ddeb69e264299ece03325135e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8dd72d0bd7a737bd6c5ffeb4b5b258"><td class="memItemLeft" align="right" valign="top"><a id="a5a8dd72d0bd7a737bd6c5ffeb4b5b258"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5a8dd72d0bd7a737bd6c5ffeb4b5b258">int8</a> = ::int8_t</td></tr>
<tr class="memdesc:a5a8dd72d0bd7a737bd6c5ffeb4b5b258"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 8bit signed integer <br /></td></tr>
<tr class="separator:a5a8dd72d0bd7a737bd6c5ffeb4b5b258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2be5bf663b4c12941fac1834282949b"><td class="memItemLeft" align="right" valign="top"><a id="ae2be5bf663b4c12941fac1834282949b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae2be5bf663b4c12941fac1834282949b">int16</a> = ::int16_t</td></tr>
<tr class="memdesc:ae2be5bf663b4c12941fac1834282949b"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 16bit signed integer <br /></td></tr>
<tr class="separator:ae2be5bf663b4c12941fac1834282949b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7463e35f2d5163201b51201e7cc6e33"><td class="memItemLeft" align="right" valign="top"><a id="ad7463e35f2d5163201b51201e7cc6e33"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">int32</a> = ::int32_t</td></tr>
<tr class="memdesc:ad7463e35f2d5163201b51201e7cc6e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 32bit signed integer <br /></td></tr>
<tr class="separator:ad7463e35f2d5163201b51201e7cc6e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29103393ac5d0d3730bdaedf5594746b"><td class="memItemLeft" align="right" valign="top"><a id="a29103393ac5d0d3730bdaedf5594746b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a29103393ac5d0d3730bdaedf5594746b">int64</a> = ::int64_t</td></tr>
<tr class="memdesc:a29103393ac5d0d3730bdaedf5594746b"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 64bit signed integer <br /></td></tr>
<tr class="separator:a29103393ac5d0d3730bdaedf5594746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8c6ef898d9ec6a50416101ba49e5f0"><td class="memItemLeft" align="right" valign="top"><a id="a9a8c6ef898d9ec6a50416101ba49e5f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a9a8c6ef898d9ec6a50416101ba49e5f0">uint8</a> = ::uint8_t</td></tr>
<tr class="memdesc:a9a8c6ef898d9ec6a50416101ba49e5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 8bit unsigned integer <br /></td></tr>
<tr class="separator:a9a8c6ef898d9ec6a50416101ba49e5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1575b4160ace5c5c8fb9155520173d"><td class="memItemLeft" align="right" valign="top"><a id="aac1575b4160ace5c5c8fb9155520173d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aac1575b4160ace5c5c8fb9155520173d">uint16</a> = ::uint16_t</td></tr>
<tr class="memdesc:aac1575b4160ace5c5c8fb9155520173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 16bit unsigned integer <br /></td></tr>
<tr class="separator:aac1575b4160ace5c5c8fb9155520173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c99409d2c9c075982db6a0cef56e8a"><td class="memItemLeft" align="right" valign="top"><a id="a47c99409d2c9c075982db6a0cef56e8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">uint32</a> = ::uint32_t</td></tr>
<tr class="memdesc:a47c99409d2c9c075982db6a0cef56e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 32bit unsigned integer <br /></td></tr>
<tr class="separator:a47c99409d2c9c075982db6a0cef56e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2dbd1cbfc05242499ea7339ee365d"><td class="memItemLeft" align="right" valign="top"><a id="acde2dbd1cbfc05242499ea7339ee365d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#acde2dbd1cbfc05242499ea7339ee365d">uint64</a> = ::uint64_t</td></tr>
<tr class="memdesc:acde2dbd1cbfc05242499ea7339ee365d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines an 64bit unsigned integer <br /></td></tr>
<tr class="separator:acde2dbd1cbfc05242499ea7339ee365d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e1c0c5dfd62c627029ac6c8d6b8c3"><td class="memItemLeft" align="right" valign="top"><a id="a044e1c0c5dfd62c627029ac6c8d6b8c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a044e1c0c5dfd62c627029ac6c8d6b8c3">int_least8</a> = ::int_least8_t</td></tr>
<tr class="memdesc:a044e1c0c5dfd62c627029ac6c8d6b8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 8bit signed integer <br /></td></tr>
<tr class="separator:a044e1c0c5dfd62c627029ac6c8d6b8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8da206aaf58d3dcaf21712380af09"><td class="memItemLeft" align="right" valign="top"><a id="ac8b8da206aaf58d3dcaf21712380af09"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac8b8da206aaf58d3dcaf21712380af09">int_least16</a> = ::int_least16_t</td></tr>
<tr class="memdesc:ac8b8da206aaf58d3dcaf21712380af09"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 16bit signed integer <br /></td></tr>
<tr class="separator:ac8b8da206aaf58d3dcaf21712380af09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8a9f53d1aee858c902ecd8ab611b51"><td class="memItemLeft" align="right" valign="top"><a id="adc8a9f53d1aee858c902ecd8ab611b51"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#adc8a9f53d1aee858c902ecd8ab611b51">int_least32</a> = ::int_least32_t</td></tr>
<tr class="memdesc:adc8a9f53d1aee858c902ecd8ab611b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 32bit signed integer <br /></td></tr>
<tr class="separator:adc8a9f53d1aee858c902ecd8ab611b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b66454668b0364e5ba1826432d611bf"><td class="memItemLeft" align="right" valign="top"><a id="a4b66454668b0364e5ba1826432d611bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4b66454668b0364e5ba1826432d611bf">int_least64</a> = ::int_least64_t</td></tr>
<tr class="memdesc:a4b66454668b0364e5ba1826432d611bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 64bit signed integer <br /></td></tr>
<tr class="separator:a4b66454668b0364e5ba1826432d611bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3861cf80735795cabe2beb7047fd6ff"><td class="memItemLeft" align="right" valign="top"><a id="af3861cf80735795cabe2beb7047fd6ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#af3861cf80735795cabe2beb7047fd6ff">uint_least8</a> = ::uint_least8_t</td></tr>
<tr class="memdesc:af3861cf80735795cabe2beb7047fd6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 8bit unsigned integer <br /></td></tr>
<tr class="separator:af3861cf80735795cabe2beb7047fd6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa357a0c1dfc432cf8f5e7aca1b6fbdb9"><td class="memItemLeft" align="right" valign="top"><a id="aa357a0c1dfc432cf8f5e7aca1b6fbdb9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa357a0c1dfc432cf8f5e7aca1b6fbdb9">uint_least16</a> = ::uint_least16_t</td></tr>
<tr class="memdesc:aa357a0c1dfc432cf8f5e7aca1b6fbdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 16bit unsigned integer <br /></td></tr>
<tr class="separator:aa357a0c1dfc432cf8f5e7aca1b6fbdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4f7dbc7d17b16619a1c0968113e83"><td class="memItemLeft" align="right" valign="top"><a id="a69c4f7dbc7d17b16619a1c0968113e83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a69c4f7dbc7d17b16619a1c0968113e83">uint_least32</a> = ::uint_least32_t</td></tr>
<tr class="memdesc:a69c4f7dbc7d17b16619a1c0968113e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 32bit unsigned integer <br /></td></tr>
<tr class="separator:a69c4f7dbc7d17b16619a1c0968113e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063a4e20aa9e6fbbf89c398767742089"><td class="memItemLeft" align="right" valign="top"><a id="a063a4e20aa9e6fbbf89c398767742089"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a063a4e20aa9e6fbbf89c398767742089">uint_least64</a> = ::uint_least64_t</td></tr>
<tr class="memdesc:a063a4e20aa9e6fbbf89c398767742089"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 64bit unsigned integer <br /></td></tr>
<tr class="separator:a063a4e20aa9e6fbbf89c398767742089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b0447d1c1a8872dd140f8d7a4d35fd"><td class="memItemLeft" align="right" valign="top"><a id="a40b0447d1c1a8872dd140f8d7a4d35fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a40b0447d1c1a8872dd140f8d7a4d35fd">int_fast8</a> = ::int_fast8_t</td></tr>
<tr class="memdesc:a40b0447d1c1a8872dd140f8d7a4d35fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 8bit signed integer with optimizations <br /></td></tr>
<tr class="separator:a40b0447d1c1a8872dd140f8d7a4d35fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1602cac7a8939bb0cc250c5531b50c88"><td class="memItemLeft" align="right" valign="top"><a id="a1602cac7a8939bb0cc250c5531b50c88"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1602cac7a8939bb0cc250c5531b50c88">int_fast16</a> = ::int_fast16_t</td></tr>
<tr class="memdesc:a1602cac7a8939bb0cc250c5531b50c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 16bit signed integer with optimizations <br /></td></tr>
<tr class="separator:a1602cac7a8939bb0cc250c5531b50c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9c0bf947c7abfca451e34d0f35579c"><td class="memItemLeft" align="right" valign="top"><a id="afa9c0bf947c7abfca451e34d0f35579c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#afa9c0bf947c7abfca451e34d0f35579c">int_fast32</a> = ::int_fast32_t</td></tr>
<tr class="memdesc:afa9c0bf947c7abfca451e34d0f35579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 32bit signed integer with optimizations <br /></td></tr>
<tr class="separator:afa9c0bf947c7abfca451e34d0f35579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35264e7e0cf73fee202276ebbc07dc32"><td class="memItemLeft" align="right" valign="top"><a id="a35264e7e0cf73fee202276ebbc07dc32"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a35264e7e0cf73fee202276ebbc07dc32">int_fast64</a> = ::int_fast64_t</td></tr>
<tr class="memdesc:a35264e7e0cf73fee202276ebbc07dc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 64bit signed integer with optimizations <br /></td></tr>
<tr class="separator:a35264e7e0cf73fee202276ebbc07dc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d2b59861f056ac8123c2285b86d605"><td class="memItemLeft" align="right" valign="top"><a id="a59d2b59861f056ac8123c2285b86d605"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a59d2b59861f056ac8123c2285b86d605">uint_fast8</a> = ::uint_fast8_t</td></tr>
<tr class="memdesc:a59d2b59861f056ac8123c2285b86d605"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 8bit unsigned integer with optimizations <br /></td></tr>
<tr class="separator:a59d2b59861f056ac8123c2285b86d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708d8a641071c3c3c56660bde6e7d31d"><td class="memItemLeft" align="right" valign="top"><a id="a708d8a641071c3c3c56660bde6e7d31d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a708d8a641071c3c3c56660bde6e7d31d">uint_fast16</a> = ::uint_fast16_t</td></tr>
<tr class="memdesc:a708d8a641071c3c3c56660bde6e7d31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 16bit unsigned integer with optimizations <br /></td></tr>
<tr class="separator:a708d8a641071c3c3c56660bde6e7d31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d3c448dfe8bc93c13c9a9eb14eab4e"><td class="memItemLeft" align="right" valign="top"><a id="a28d3c448dfe8bc93c13c9a9eb14eab4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a28d3c448dfe8bc93c13c9a9eb14eab4e">uint_fast32</a> = ::uint_fast32_t</td></tr>
<tr class="memdesc:a28d3c448dfe8bc93c13c9a9eb14eab4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 32bit unsigned integer with optimizations <br /></td></tr>
<tr class="separator:a28d3c448dfe8bc93c13c9a9eb14eab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0429251ccd43d015b436169f218b15"><td class="memItemLeft" align="right" valign="top"><a id="a8e0429251ccd43d015b436169f218b15"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a8e0429251ccd43d015b436169f218b15">uint_fast64</a> = ::uint_fast64_t</td></tr>
<tr class="memdesc:a8e0429251ccd43d015b436169f218b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines at least an 64bit unsigned integer with optimizations <br /></td></tr>
<tr class="separator:a8e0429251ccd43d015b436169f218b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b0bf43d8f31a261545793591b4cc88"><td class="memItemLeft" align="right" valign="top"><a id="ab2b0bf43d8f31a261545793591b4cc88"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab2b0bf43d8f31a261545793591b4cc88">intptr</a> = ::intptr_t</td></tr>
<tr class="memdesc:ab2b0bf43d8f31a261545793591b4cc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a signed integer the size of a void * <br /></td></tr>
<tr class="separator:ab2b0bf43d8f31a261545793591b4cc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbe4625bac9ffc4c32a6997534e939b"><td class="memItemLeft" align="right" valign="top"><a id="a4bbe4625bac9ffc4c32a6997534e939b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4bbe4625bac9ffc4c32a6997534e939b">uintptr</a> = ::uintptr_t</td></tr>
<tr class="memdesc:a4bbe4625bac9ffc4c32a6997534e939b"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a unsigned integer the size of a void * <br /></td></tr>
<tr class="separator:a4bbe4625bac9ffc4c32a6997534e939b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94a881664490f5a16f9950bada1a8c"><td class="memItemLeft" align="right" valign="top"><a id="a0f94a881664490f5a16f9950bada1a8c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0f94a881664490f5a16f9950bada1a8c">intmax</a> = ::intmax_t</td></tr>
<tr class="memdesc:a0f94a881664490f5a16f9950bada1a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a signed integer with the maximum possible size <br /></td></tr>
<tr class="separator:a0f94a881664490f5a16f9950bada1a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5cecf5ad79f6cbfc4c7ab77dc09ac9"><td class="memItemLeft" align="right" valign="top"><a id="adf5cecf5ad79f6cbfc4c7ab77dc09ac9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">uintmax</a> = ::uintmax_t</td></tr>
<tr class="memdesc:adf5cecf5ad79f6cbfc4c7ab77dc09ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines a unsigned integer with the maximum possible size <br /></td></tr>
<tr class="separator:adf5cecf5ad79f6cbfc4c7ab77dc09ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0636b7a3243bed71b235bafacc7208"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> = char const *</td></tr>
<tr class="memdesc:a0e0636b7a3243bed71b235bafacc7208"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style string type.  <a href="#a0e0636b7a3243bed71b235bafacc7208">More...</a><br /></td></tr>
<tr class="separator:a0e0636b7a3243bed71b235bafacc7208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7c17739499d031008ba99fed3a0b9"><td class="memTemplParams" colspan="2"><a id="a75f7c17739499d031008ba99fed3a0b9"></a>
template&lt;bsl::uintmax DL, typename T &gt; </td></tr>
<tr class="memitem:a75f7c17739499d031008ba99fed3a0b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a75f7c17739499d031008ba99fed3a0b9">out_t</a> = <a class="el" href="namespacebsl.html#a4f1cc2f9cd1ea0202b54f4237ecd1e66">conditional_t</a>&lt; DL&lt;=BSL_DEBUG_LEVEL, out&lt; T &gt;, out&lt; details::out_type_empty &gt; &gt;</td></tr>
<tr class="memdesc:a75f7c17739499d031008ba99fed3a0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to disable debugging for <a class="el" href="namespacebsl.html#a0b4a9c10ac4501e78b4a7ea9c14c52b4" title="Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints &quot;DEBUG: &quot; when created and ac...">debug()</a> and <a class="el" href="namespacebsl.html#ad9cfc8786fe5806f3f16b8d7ebbc454a" title="Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints &quot;ALERT: &quot; when created and ac...">alert()</a> <br /></td></tr>
<tr class="separator:a75f7c17739499d031008ba99fed3a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ff5c8eede87517bf5d385b3111a228"><td class="memTemplParams" colspan="2"><a id="aa6ff5c8eede87517bf5d385b3111a228"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6ff5c8eede87517bf5d385b3111a228"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa6ff5c8eede87517bf5d385b3111a228">decay_t</a> = typename <a class="el" href="structbsl_1_1decay.html">decay</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:aa6ff5c8eede87517bf5d385b3111a228"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1decay.html" title="Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type ...">bsl::decay</a> <br /></td></tr>
<tr class="separator:aa6ff5c8eede87517bf5d385b3111a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ad4f1e3643f1cfdb49193096533815"><td class="memTemplParams" colspan="2"><a id="a70ad4f1e3643f1cfdb49193096533815"></a>
template&lt;template&lt; class... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a70ad4f1e3643f1cfdb49193096533815"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a70ad4f1e3643f1cfdb49193096533815">detected_t</a> = typename details::detector&lt; <a class="el" href="classbsl_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::type</td></tr>
<tr class="memdesc:a70ad4f1e3643f1cfdb49193096533815"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template detected_t is equivalent to typename detected_or&lt;bsl::nonesuch, Op, Args...&gt;::type. It is an alias for Op&lt;Args...&gt; if that template-id denotes a valid type; otherwise it is an alias for the class <a class="el" href="classbsl_1_1nonesuch.html" title="Used by is_detected to indicate detection failure.">bsl::nonesuch</a>. <br /></td></tr>
<tr class="separator:a70ad4f1e3643f1cfdb49193096533815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9190ab55dc7106ba972bcee4648ef3"><td class="memTemplParams" colspan="2">template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a4e9190ab55dc7106ba972bcee4648ef3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4e9190ab55dc7106ba972bcee4648ef3">detected_or</a> = details::detector&lt; Default, void, Op, Args... &gt;</td></tr>
<tr class="memdesc:a4e9190ab55dc7106ba972bcee4648ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template detected_or is an alias for an unspecified class type with two public member typedefs value_t and type, which are defined as follows:  <a href="#a4e9190ab55dc7106ba972bcee4648ef3">More...</a><br /></td></tr>
<tr class="separator:a4e9190ab55dc7106ba972bcee4648ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ceaa49cb52546ad42dbbc8c32f986c"><td class="memTemplParams" colspan="2"><a id="a99ceaa49cb52546ad42dbbc8c32f986c"></a>
template&lt;typename Default , template&lt; class... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a99ceaa49cb52546ad42dbbc8c32f986c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a99ceaa49cb52546ad42dbbc8c32f986c">detected_or_t</a> = typename details::detector&lt; Default, void, Op, Args... &gt;::type</td></tr>
<tr class="memdesc:a99ceaa49cb52546ad42dbbc8c32f986c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="namespacebsl.html#a4e9190ab55dc7106ba972bcee4648ef3" title="The alias template detected_or is an alias for an unspecified class type with two public member typed...">bsl::detected_or</a> <br /></td></tr>
<tr class="separator:a99ceaa49cb52546ad42dbbc8c32f986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e50a30f5c124ac0c32689c90375333"><td class="memTemplParams" colspan="2"><a id="a06e50a30f5c124ac0c32689c90375333"></a>
template&lt;bool B, typename T  = void&gt; </td></tr>
<tr class="memitem:a06e50a30f5c124ac0c32689c90375333"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a> = typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:a06e50a30f5c124ac0c32689c90375333"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1enable__if.html" title="Defines a conditional &quot;if&quot; statement for SFINAE overload resolution. If B is true,...">bsl::enable_if</a> <br /></td></tr>
<tr class="separator:a06e50a30f5c124ac0c32689c90375333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5e36d8b13e4eb51b5c8d152cdcf9c6"><td class="memItemLeft" align="right" valign="top"><a id="aad5e36d8b13e4eb51b5c8d152cdcf9c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aad5e36d8b13e4eb51b5c8d152cdcf9c6">exit_code</a> = <a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a></td></tr>
<tr class="memdesc:aad5e36d8b13e4eb51b5c8d152cdcf9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the exit code type <br /></td></tr>
<tr class="separator:aad5e36d8b13e4eb51b5c8d152cdcf9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a5338ec760fc73a47f2166e4d29546"><td class="memItemLeft" align="right" valign="top"><a id="a12a5338ec760fc73a47f2166e4d29546"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a12a5338ec760fc73a47f2166e4d29546">false_type</a> = <a class="el" href="namespacebsl.html#aab545b3015440be59ef0bf70ddc3a45a">bool_constant</a>&lt; false &gt;</td></tr>
<tr class="memdesc:a12a5338ec760fc73a47f2166e4d29546"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides a bool_constant that represents "false" <br /></td></tr>
<tr class="separator:a12a5338ec760fc73a47f2166e4d29546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f97b8884c01ebba8e8bcbf07b3863"><td class="memTemplParams" colspan="2"><a id="a443f97b8884c01ebba8e8bcbf07b3863"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:a443f97b8884c01ebba8e8bcbf07b3863"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a443f97b8884c01ebba8e8bcbf07b3863">false_type_for</a> = <a class="el" href="namespacebsl.html#a12a5338ec760fc73a47f2166e4d29546">false_type</a></td></tr>
<tr class="memdesc:a443f97b8884c01ebba8e8bcbf07b3863"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides a bool_constant that represents "true" <br /></td></tr>
<tr class="separator:a443f97b8884c01ebba8e8bcbf07b3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d76831b0c34b3a08224f4ee0030178"><td class="memTemplParams" colspan="2"><a id="a75d76831b0c34b3a08224f4ee0030178"></a>
template&lt;bsl::uintmax... INTS&gt; </td></tr>
<tr class="memitem:a75d76831b0c34b3a08224f4ee0030178"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a75d76831b0c34b3a08224f4ee0030178">index_sequence</a> = <a class="el" href="classbsl_1_1integer__sequence.html">integer_sequence</a>&lt; <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>, INTS... &gt;</td></tr>
<tr class="memdesc:a75d76831b0c34b3a08224f4ee0030178"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper alias template for the common case of <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9" title="defines a unsigned integer with the maximum possible size">bsl::uintmax</a> <br /></td></tr>
<tr class="separator:a75d76831b0c34b3a08224f4ee0030178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e548a94d5d2cb0d9df3b884c09873"><td class="memTemplParams" colspan="2"><a id="aa36e548a94d5d2cb0d9df3b884c09873"></a>
template&lt;typename T , T N&gt; </td></tr>
<tr class="memitem:aa36e548a94d5d2cb0d9df3b884c09873"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa36e548a94d5d2cb0d9df3b884c09873">make_integer_sequence</a> = __make_integer_seq&lt; <a class="el" href="classbsl_1_1integer__sequence.html">integer_sequence</a>, T, N &gt;</td></tr>
<tr class="memdesc:aa36e548a94d5d2cb0d9df3b884c09873"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper alias that makes integer sequences <br /></td></tr>
<tr class="separator:aa36e548a94d5d2cb0d9df3b884c09873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41d1984f1978a6ec1821c1859b46322"><td class="memTemplParams" colspan="2"><a id="ab41d1984f1978a6ec1821c1859b46322"></a>
template&lt;bsl::uintmax N&gt; </td></tr>
<tr class="memitem:ab41d1984f1978a6ec1821c1859b46322"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab41d1984f1978a6ec1821c1859b46322">make_index_sequence</a> = <a class="el" href="namespacebsl.html#aa36e548a94d5d2cb0d9df3b884c09873">make_integer_sequence</a>&lt; <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>, N &gt;</td></tr>
<tr class="memdesc:ab41d1984f1978a6ec1821c1859b46322"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper alias that makes integer sequences for <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9" title="defines a unsigned integer with the maximum possible size">bsl::uintmax</a> <br /></td></tr>
<tr class="separator:ab41d1984f1978a6ec1821c1859b46322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fd17aa431672aca8493f761d8639fd"><td class="memTemplParams" colspan="2"><a id="ae5fd17aa431672aca8493f761d8639fd"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ae5fd17aa431672aca8493f761d8639fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae5fd17aa431672aca8493f761d8639fd">index_sequence_for</a> = <a class="el" href="namespacebsl.html#ab41d1984f1978a6ec1821c1859b46322">make_index_sequence</a>&lt; sizeof...(T)&gt;</td></tr>
<tr class="memdesc:ae5fd17aa431672aca8493f761d8639fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper alias that makes an index sequence given a list of types <br /></td></tr>
<tr class="separator:ae5fd17aa431672aca8493f761d8639fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad734e41c64ad6aa419a9ec6bf642f39e"><td class="memTemplParams" colspan="2"><a id="ad734e41c64ad6aa419a9ec6bf642f39e"></a>
template&lt;typename FUNC , typename... TN&gt; </td></tr>
<tr class="memitem:ad734e41c64ad6aa419a9ec6bf642f39e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad734e41c64ad6aa419a9ec6bf642f39e">invoke_result_t</a> = typename <a class="el" href="classbsl_1_1invoke__result.html">invoke_result</a>&lt; FUNC, TN... &gt;::type</td></tr>
<tr class="memdesc:ad734e41c64ad6aa419a9ec6bf642f39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="classbsl_1_1invoke__result.html" title="Provides the member typedef type which is the result of calling bsl::invoke&lt;F, ARGS....">bsl::invoke_result</a> <br /></td></tr>
<tr class="separator:ad734e41c64ad6aa419a9ec6bf642f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16b997cb1f8bf5bf5a237450cafdef5"><td class="memTemplParams" colspan="2"><a id="aa16b997cb1f8bf5bf5a237450cafdef5"></a>
template&lt;template&lt; class... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:aa16b997cb1f8bf5bf5a237450cafdef5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa16b997cb1f8bf5bf5a237450cafdef5">is_detected</a> = typename details::detector&lt; <a class="el" href="classbsl_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::value_t</td></tr>
<tr class="memdesc:aa16b997cb1f8bf5bf5a237450cafdef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template is_detected is equivalent to typename detected_or&lt;bsl::nonesuch, Op, Args...&gt;::value_t. It is an alias for <a class="el" href="namespacebsl.html#a5aa75d729f1e40765ab7e9b8fe327789" title="provides a bool_constant that represents &quot;true&quot;">bsl::true_type</a> if the template-id Op&lt;Args...&gt; denotes a valid type; otherwise it is an alias for <a class="el" href="namespacebsl.html#a12a5338ec760fc73a47f2166e4d29546" title="provides a bool_constant that represents &quot;false&quot;">bsl::false_type</a>. <br /></td></tr>
<tr class="separator:aa16b997cb1f8bf5bf5a237450cafdef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a4ef4ff3d6e07d5c37962c3cf1c0ea"><td class="memTemplParams" colspan="2"><a id="a47a4ef4ff3d6e07d5c37962c3cf1c0ea"></a>
template&lt;class Expected , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a47a4ef4ff3d6e07d5c37962c3cf1c0ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a47a4ef4ff3d6e07d5c37962c3cf1c0ea">is_detected_exact</a> = <a class="el" href="classbsl_1_1is__same.html">is_same</a>&lt; Expected, <a class="el" href="namespacebsl.html#a70ad4f1e3643f1cfdb49193096533815">detected_t</a>&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="memdesc:a47a4ef4ff3d6e07d5c37962c3cf1c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template is_detected_exact checks whether detected_t&lt;Op, Args...&gt; is Expected. <br /></td></tr>
<tr class="separator:a47a4ef4ff3d6e07d5c37962c3cf1c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad549b285e5d5b8eee048b16400cc7bfd"><td class="memTemplParams" colspan="2"><a id="ad549b285e5d5b8eee048b16400cc7bfd"></a>
template&lt;class To , template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:ad549b285e5d5b8eee048b16400cc7bfd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad549b285e5d5b8eee048b16400cc7bfd">is_detected_convertible</a> = <a class="el" href="classbsl_1_1is__convertible.html">is_convertible</a>&lt; <a class="el" href="namespacebsl.html#a70ad4f1e3643f1cfdb49193096533815">detected_t</a>&lt; Op, Args... &gt;, To &gt;</td></tr>
<tr class="memdesc:ad549b285e5d5b8eee048b16400cc7bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template is_detected_convertible checks whether detected_t&lt;Op, Args...&gt; is convertible to To. <br /></td></tr>
<tr class="separator:ad549b285e5d5b8eee048b16400cc7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4056f69d9666f2915bb992bbeefc07"><td class="memTemplParams" colspan="2"><a id="adf4056f69d9666f2915bb992bbeefc07"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf4056f69d9666f2915bb992bbeefc07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#adf4056f69d9666f2915bb992bbeefc07">make_signed_t</a> = typename <a class="el" href="structbsl_1_1make__signed.html">make_signed</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:adf4056f69d9666f2915bb992bbeefc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1make__signed.html" title="If the provided type is an unsigned type (taking into account const qualifications),...">bsl::make_signed</a> <br /></td></tr>
<tr class="separator:adf4056f69d9666f2915bb992bbeefc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ef9a26ff4966892ab97a0ab574e9fc"><td class="memTemplParams" colspan="2"><a id="a98ef9a26ff4966892ab97a0ab574e9fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98ef9a26ff4966892ab97a0ab574e9fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a98ef9a26ff4966892ab97a0ab574e9fc">make_unsigned_t</a> = typename <a class="el" href="structbsl_1_1make__unsigned.html">make_unsigned</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a98ef9a26ff4966892ab97a0ab574e9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1make__unsigned.html" title="If the provided type is an signed type (taking into account const qualifications),...">bsl::make_unsigned</a> <br /></td></tr>
<tr class="separator:a98ef9a26ff4966892ab97a0ab574e9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61932d266abd949d540ebce7ed1328d8"><td class="memItemLeft" align="right" valign="top"><a id="a61932d266abd949d540ebce7ed1328d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a61932d266abd949d540ebce7ed1328d8">max_align_t</a> = <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a></td></tr>
<tr class="memdesc:a61932d266abd949d540ebce7ed1328d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max scalar type alignment. <br /></td></tr>
<tr class="separator:a61932d266abd949d540ebce7ed1328d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405a7411e59f5a4ca032aab3163616ab"><td class="memTemplParams" colspan="2"><a id="a405a7411e59f5a4ca032aab3163616ab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a405a7411e59f5a4ca032aab3163616ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a405a7411e59f5a4ca032aab3163616ab">remove_all_extents_t</a> = typename <a class="el" href="structbsl_1_1remove__all__extents.html">remove_all_extents</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a405a7411e59f5a4ca032aab3163616ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__all__extents.html" title="Provides the member typedef type which is the same as T, except that its topmost extent is removed.">bsl::remove_all_extents</a> <br /></td></tr>
<tr class="separator:a405a7411e59f5a4ca032aab3163616ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16567c5d7be1209aa263468f08f3de7e"><td class="memTemplParams" colspan="2"><a id="a16567c5d7be1209aa263468f08f3de7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16567c5d7be1209aa263468f08f3de7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a16567c5d7be1209aa263468f08f3de7e">remove_const_t</a> = typename <a class="el" href="structbsl_1_1remove__const.html">remove_const</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a16567c5d7be1209aa263468f08f3de7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__const.html" title="Provides the member typedef type which is the same as T, except that its topmost const qualifier is r...">bsl::remove_const</a> <br /></td></tr>
<tr class="separator:a16567c5d7be1209aa263468f08f3de7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003bb163749363331f610967edfa314"><td class="memTemplParams" colspan="2"><a id="ac003bb163749363331f610967edfa314"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac003bb163749363331f610967edfa314"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac003bb163749363331f610967edfa314">remove_cv_t</a> = typename <a class="el" href="structbsl_1_1remove__cv.html">remove_cv</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ac003bb163749363331f610967edfa314"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__cv.html" title="Provides the member typedef type which is the same as T, except that its topmost const and volatile q...">bsl::remove_cv</a> <br /></td></tr>
<tr class="separator:ac003bb163749363331f610967edfa314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fdacec4323a3559ed4483ef2da7860"><td class="memTemplParams" colspan="2"><a id="a57fdacec4323a3559ed4483ef2da7860"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57fdacec4323a3559ed4483ef2da7860"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a57fdacec4323a3559ed4483ef2da7860">remove_cvext_t</a> = typename <a class="el" href="structbsl_1_1remove__cvext.html">remove_cvext</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a57fdacec4323a3559ed4483ef2da7860"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__cvext.html" title="Provides the member typedef type which is the same as T, except that its topmost const,...">bsl::remove_cvext</a> <br /></td></tr>
<tr class="separator:a57fdacec4323a3559ed4483ef2da7860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8b2914607ce175c9b1e8723f4d8ab0"><td class="memTemplParams" colspan="2"><a id="aba8b2914607ce175c9b1e8723f4d8ab0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba8b2914607ce175c9b1e8723f4d8ab0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aba8b2914607ce175c9b1e8723f4d8ab0">remove_cvref_t</a> = typename <a class="el" href="structbsl_1_1remove__cvref.html">remove_cvref</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:aba8b2914607ce175c9b1e8723f4d8ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__cvref.html" title="Provides the member typedef type which is the same as T, except that its topmost const,...">bsl::remove_cvref</a> <br /></td></tr>
<tr class="separator:aba8b2914607ce175c9b1e8723f4d8ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade77479668a6d6dac16799ed8e0b2bb3"><td class="memTemplParams" colspan="2"><a id="ade77479668a6d6dac16799ed8e0b2bb3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade77479668a6d6dac16799ed8e0b2bb3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ade77479668a6d6dac16799ed8e0b2bb3">remove_extent_t</a> = typename <a class="el" href="structbsl_1_1remove__extent.html">remove_extent</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ade77479668a6d6dac16799ed8e0b2bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__extent.html" title="Provides the member typedef type which is the same as T, except that its topmost extent is removed.">bsl::remove_extent</a> <br /></td></tr>
<tr class="separator:ade77479668a6d6dac16799ed8e0b2bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f25f24c08bd14019b7456130fa43ef"><td class="memTemplParams" colspan="2"><a id="a63f25f24c08bd14019b7456130fa43ef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63f25f24c08bd14019b7456130fa43ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a63f25f24c08bd14019b7456130fa43ef">remove_pointer_t</a> = typename <a class="el" href="structbsl_1_1remove__pointer.html">remove_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a63f25f24c08bd14019b7456130fa43ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__pointer.html" title="Provides the member typedef type which is the same as T, except that its topmost pointer is removed.">bsl::remove_pointer</a> <br /></td></tr>
<tr class="separator:a63f25f24c08bd14019b7456130fa43ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9d843459e2d510c4bab126a9dd251d"><td class="memTemplParams" colspan="2"><a id="afb9d843459e2d510c4bab126a9dd251d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb9d843459e2d510c4bab126a9dd251d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">remove_reference_t</a> = typename <a class="el" href="structbsl_1_1remove__reference.html">remove_reference</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:afb9d843459e2d510c4bab126a9dd251d"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__reference.html" title="Provides the member typedef type which is the same as T, except that its topmost reference is removed...">bsl::remove_reference</a> <br /></td></tr>
<tr class="separator:afb9d843459e2d510c4bab126a9dd251d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050f56d26f0be0cdf85bfc2cbe559f4f"><td class="memTemplParams" colspan="2"><a id="a050f56d26f0be0cdf85bfc2cbe559f4f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a050f56d26f0be0cdf85bfc2cbe559f4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a050f56d26f0be0cdf85bfc2cbe559f4f">remove_volatile_t</a> = typename <a class="el" href="structbsl_1_1remove__volatile.html">remove_volatile</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a050f56d26f0be0cdf85bfc2cbe559f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1remove__volatile.html" title="Provides the member typedef type which is the same as T, except that its topmost volatile qualifier i...">bsl::remove_volatile</a> <br /></td></tr>
<tr class="separator:a050f56d26f0be0cdf85bfc2cbe559f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fefedc73c85f9a67d6028a786648e09"><td class="memItemLeft" align="right" valign="top"><a id="a5fefedc73c85f9a67d6028a786648e09"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5fefedc73c85f9a67d6028a786648e09">sloc_type</a> = <a class="el" href="classbsl_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:a5fefedc73c85f9a67d6028a786648e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the type used to describe a <a class="el" href="classbsl_1_1source__location.html" title="This class implements the source_location specification that will eventually be included in C++20....">bsl::source_location</a> <br /></td></tr>
<tr class="separator:a5fefedc73c85f9a67d6028a786648e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa75d729f1e40765ab7e9b8fe327789"><td class="memItemLeft" align="right" valign="top"><a id="a5aa75d729f1e40765ab7e9b8fe327789"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5aa75d729f1e40765ab7e9b8fe327789">true_type</a> = <a class="el" href="namespacebsl.html#aab545b3015440be59ef0bf70ddc3a45a">bool_constant</a>&lt; true &gt;</td></tr>
<tr class="memdesc:a5aa75d729f1e40765ab7e9b8fe327789"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides a bool_constant that represents "true" <br /></td></tr>
<tr class="separator:a5aa75d729f1e40765ab7e9b8fe327789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d75e8befe697900fcd9d9a0ba946a1"><td class="memTemplParams" colspan="2"><a id="ac8d75e8befe697900fcd9d9a0ba946a1"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:ac8d75e8befe697900fcd9d9a0ba946a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac8d75e8befe697900fcd9d9a0ba946a1">true_type_for</a> = <a class="el" href="namespacebsl.html#a5aa75d729f1e40765ab7e9b8fe327789">true_type</a></td></tr>
<tr class="memdesc:ac8d75e8befe697900fcd9d9a0ba946a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides a bool_constant that represents "true" <br /></td></tr>
<tr class="separator:ac8d75e8befe697900fcd9d9a0ba946a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad099f3b6a909477b132c99518df5206c"><td class="memTemplParams" colspan="2"><a id="ad099f3b6a909477b132c99518df5206c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad099f3b6a909477b132c99518df5206c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad099f3b6a909477b132c99518df5206c">type_identity_t</a> = typename <a class="el" href="structbsl_1_1type__identity.html">type_identity</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ad099f3b6a909477b132c99518df5206c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1type__identity.html" title="Provides the member typedef &quot;type&quot; that names T (i.e., the identity transformation).">bsl::type_identity</a> <br /></td></tr>
<tr class="separator:ad099f3b6a909477b132c99518df5206c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f786b60012a45b337bb3b2bc353c95c"><td class="memTemplParams" colspan="2"><a id="a4f786b60012a45b337bb3b2bc353c95c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f786b60012a45b337bb3b2bc353c95c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4f786b60012a45b337bb3b2bc353c95c">underlying_type_t</a> = typename <a class="el" href="structbsl_1_1underlying__type.html">underlying_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4f786b60012a45b337bb3b2bc353c95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper that reduces the verbosity of <a class="el" href="structbsl_1_1underlying__type.html" title="If T is a complete enumeration type, provides a member typedef type that names the underlying type of...">bsl::underlying_type</a> <br /></td></tr>
<tr class="separator:a4f786b60012a45b337bb3b2bc353c95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3d29acb0c4477afb5958bf9329cd27"><td class="memTemplParams" colspan="2"><a id="a3b3d29acb0c4477afb5958bf9329cd27"></a>
template&lt;typename... &gt; </td></tr>
<tr class="memitem:a3b3d29acb0c4477afb5958bf9329cd27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3b3d29acb0c4477afb5958bf9329cd27">void_t</a> = void</td></tr>
<tr class="memdesc:a3b3d29acb0c4477afb5958bf9329cd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that maps a sequence of any types to the type void. <br /></td></tr>
<tr class="separator:a3b3d29acb0c4477afb5958bf9329cd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af46da9d0f3a7e8f290422068efa9d726"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#af46da9d0f3a7e8f290422068efa9d726">float_denorm_style</a> : bsl::int32 { <b>denorm_indeterminate</b> = -1, 
<b>denorm_absent</b> = 0, 
<b>denorm_present</b> = 1
 }</td></tr>
<tr class="memdesc:af46da9d0f3a7e8f290422068efa9d726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates subnormal values for floating points.  <a href="namespacebsl.html#af46da9d0f3a7e8f290422068efa9d726">More...</a><br /></td></tr>
<tr class="separator:af46da9d0f3a7e8f290422068efa9d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485215e55d01b8cae1a82da0a286b91a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a485215e55d01b8cae1a82da0a286b91a">float_round_style</a> : bsl::int32 { <br />
&#160;&#160;<b>round_indeterminate</b> = -1, 
<b>round_toward_zero</b> = 0, 
<b>round_to_nearest</b> = 1, 
<b>round_toward_infinity</b> = 2, 
<br />
&#160;&#160;<b>round_toward_neg_infinity</b> = 3
<br />
 }</td></tr>
<tr class="memdesc:a485215e55d01b8cae1a82da0a286b91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates round styles for floating points.  <a href="namespacebsl.html#a485215e55d01b8cae1a82da0a286b91a">More...</a><br /></td></tr>
<tr class="separator:a485215e55d01b8cae1a82da0a286b91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6092baa0883a26f2f864ff0db979ee0"><td class="memItemLeft" align="right" valign="top"><a id="ac6092baa0883a26f2f864ff0db979ee0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac6092baa0883a26f2f864ff0db979ee0">fmt_align</a> : bsl::uint32 { <b>fmt_align_default</b> = 0U, 
<b>fmt_align_left</b> = 1U, 
<b>fmt_align_right</b> = 2U, 
<b>fmt_align_center</b> = 3U
 }</td></tr>
<tr class="memdesc:ac6092baa0883a26f2f864ff0db979ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine what the alignment of the output should be. If the width is not defined, this field does nothing. <br /></td></tr>
<tr class="separator:ac6092baa0883a26f2f864ff0db979ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cc2d74ace27c13f691e127f491917b"><td class="memItemLeft" align="right" valign="top"><a id="a58cc2d74ace27c13f691e127f491917b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a58cc2d74ace27c13f691e127f491917b">fmt_sign</a> : bsl::uint32 { <b>fmt_sign_neg_only</b> = 0U, 
<b>fmt_sign_pos_neg</b> = 1U, 
<b>fmt_sign_space_for_pos</b> = 3U
 }</td></tr>
<tr class="memdesc:a58cc2d74ace27c13f691e127f491917b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine how an integral's sign field is handled. This only has an effect on signed types. <br /></td></tr>
<tr class="separator:a58cc2d74ace27c13f691e127f491917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c170f4f27623e05767f5b73ea33cd0"><td class="memItemLeft" align="right" valign="top"><a id="ad2c170f4f27623e05767f5b73ea33cd0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad2c170f4f27623e05767f5b73ea33cd0">fmt_type</a> : bsl::uint32 { <br />
&#160;&#160;<b>fmt_type_default</b> = 0U, 
<b>fmt_type_b</b> = 1U, 
<b>fmt_type_c</b> = 2U, 
<b>fmt_type_d</b> = 3U, 
<br />
&#160;&#160;<b>fmt_type_s</b> = 4U, 
<b>fmt_type_x</b> = 5U
<br />
 }</td></tr>
<tr class="memdesc:ad2c170f4f27623e05767f5b73ea33cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine how to output an unsigned integer type (either as hex or dec). All ofther {fmt} types are currently not supported and this has no effect on signed integer types. <br /></td></tr>
<tr class="separator:ad2c170f4f27623e05767f5b73ea33cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1606d20b803f9b7b2be5072df4028435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1606d20b803f9b7b2be5072df4028435"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1606d20b803f9b7b2be5072df4028435">addressof</a> (T &amp;val) noexcept</td></tr>
<tr class="memdesc:a1606d20b803f9b7b2be5072df4028435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp; (i.e., this should be used to get the address of an object instead of using &amp; as that could be unsafe).  <a href="#a1606d20b803f9b7b2be5072df4028435">More...</a><br /></td></tr>
<tr class="separator:a1606d20b803f9b7b2be5072df4028435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f5e6825e9000d5b4fa8dab99bf4ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff0f5e6825e9000d5b4fa8dab99bf4ac"><td class="memTemplItemLeft" align="right" valign="top">T const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aff0f5e6825e9000d5b4fa8dab99bf4ac">addressof</a> (T const &amp;&amp;val)=delete</td></tr>
<tr class="memdesc:aff0f5e6825e9000d5b4fa8dab99bf4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents the user from getting an address to a const as that would allow you to get the address of an rvalue which could result in UB.  <a href="#aff0f5e6825e9000d5b4fa8dab99bf4ac">More...</a><br /></td></tr>
<tr class="separator:aff0f5e6825e9000d5b4fa8dab99bf4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762a45828b89392aacded2a3d813ccdf"><td class="memTemplParams" colspan="2"><a id="a762a45828b89392aacded2a3d813ccdf"></a>
template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a762a45828b89392aacded2a3d813ccdf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a762a45828b89392aacded2a3d813ccdf">array</a> (T, U...) -&gt; <a class="el" href="classbsl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td></tr>
<tr class="memdesc:a762a45828b89392aacded2a3d813ccdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">deduction guideline for <a class="el" href="classbsl_1_1array.html" title="Provides a safe encapsulation for a C-style array, minicing the std::array APIs. This container is an...">bsl::array</a> <br /></td></tr>
<tr class="separator:a762a45828b89392aacded2a3d813ccdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe65822a59d3f1a702390d3c1b345230"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe65822a59d3f1a702390d3c1b345230"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a1a151f8f27c4d3e44230d246481ffd29">add_const_t</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#abe65822a59d3f1a702390d3c1b345230">as_const</a> (T &amp;t) noexcept</td></tr>
<tr class="memdesc:abe65822a59d3f1a702390d3c1b345230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms lvalue reference to const type of t.  <a href="#abe65822a59d3f1a702390d3c1b345230">More...</a><br /></td></tr>
<tr class="separator:abe65822a59d3f1a702390d3c1b345230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa398963dd4a1ea7499fb63a1313749"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fa398963dd4a1ea7499fb63a1313749"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a7fa398963dd4a1ea7499fb63a1313749">as_const</a> (T const &amp;&amp;t) noexcept=delete</td></tr>
<tr class="memdesc:a7fa398963dd4a1ea7499fb63a1313749"><td class="mdescLeft">&#160;</td><td class="mdescRight">const rvalue reference overload is deleted to disallow rvalue arguments  <a href="#a7fa398963dd4a1ea7499fb63a1313749">More...</a><br /></td></tr>
<tr class="separator:a7fa398963dd4a1ea7499fb63a1313749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d0251f0a23b36f18e62e91926bc931"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... ARGS&gt; </td></tr>
<tr class="memitem:ac7d0251f0a23b36f18e62e91926bc931"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac7d0251f0a23b36f18e62e91926bc931">construct_at</a> (void *const ptr, ARGS &amp;&amp;... args) noexcept(noexcept(std::construct_at_impl&lt; T, ARGS... &gt;(ptr, <a class="el" href="namespacebsl.html#aa19e79c525543d028b9b0bdb56d022c1">bsl::declval</a>&lt; ARGS &gt;()...)))</td></tr>
<tr class="memdesc:ac7d0251f0a23b36f18e62e91926bc931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constexpr version of placement new. that can be used by BSL's APIs to support constexpr based APIs.  <a href="#ac7d0251f0a23b36f18e62e91926bc931">More...</a><br /></td></tr>
<tr class="separator:ac7d0251f0a23b36f18e62e91926bc931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ea1baadedc7f43c5f6aa4db5f9bae3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae4ea1baadedc7f43c5f6aa4db5f9bae3">builtin_memset</a> (void *const dst, <a class="el" href="namespacebsl.html#a5a8dd72d0bd7a737bd6c5ffeb4b5b258">bsl::int8</a> const ch, <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const count) noexcept</td></tr>
<tr class="memdesc:ae4ea1baadedc7f43c5f6aa4db5f9bae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::memset with parameter checks. If dst is a nullptr, or count is 0, this function returns a nullptr without doing anything.  <a href="#ae4ea1baadedc7f43c5f6aa4db5f9bae3">More...</a><br /></td></tr>
<tr class="separator:ae4ea1baadedc7f43c5f6aa4db5f9bae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3198a0e407e0ca0f326c36746bc0dba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a3198a0e407e0ca0f326c36746bc0dba5">builtin_memcmp</a> (void const *const lhs, void const *const rhs, <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const count) noexcept</td></tr>
<tr class="memdesc:a3198a0e407e0ca0f326c36746bc0dba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::memcmp with parameter checks. If lhs, rhs are a nullptr, or count is 0, this function returns 0.  <a href="#a3198a0e407e0ca0f326c36746bc0dba5">More...</a><br /></td></tr>
<tr class="separator:a3198a0e407e0ca0f326c36746bc0dba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6d7dbac3d1c7d2a70a8284ae996ed4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1c6d7dbac3d1c7d2a70a8284ae996ed4">builtin_strncmp</a> (<a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const lhs, <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const rhs, <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const count) noexcept</td></tr>
<tr class="memdesc:a1c6d7dbac3d1c7d2a70a8284ae996ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::strncmp with parameter checks. If lhs, rhs are a nullptr, or count is 0, this function returns 0.  <a href="#a1c6d7dbac3d1c7d2a70a8284ae996ed4">More...</a><br /></td></tr>
<tr class="separator:a1c6d7dbac3d1c7d2a70a8284ae996ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb26dc11b55d83f3215aa728c80128a9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#adb26dc11b55d83f3215aa728c80128a9">builtin_strlen</a> (<a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const str) noexcept</td></tr>
<tr class="memdesc:adb26dc11b55d83f3215aa728c80128a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::strlen with parameter checks. If str is a nullptr, this returns 0.  <a href="#adb26dc11b55d83f3215aa728c80128a9">More...</a><br /></td></tr>
<tr class="separator:adb26dc11b55d83f3215aa728c80128a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bdb4dd6de182919b109a16956605fa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad0bdb4dd6de182919b109a16956605fa">builtin_strnchr</a> (<a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const str, <a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">char_type</a> const ch, <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const count) noexcept</td></tr>
<tr class="memdesc:ad0bdb4dd6de182919b109a16956605fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::strnchr with parameter checks. If str is a nullptr, or count is 0, this function returns a nullptr.  <a href="#ad0bdb4dd6de182919b109a16956605fa">More...</a><br /></td></tr>
<tr class="separator:ad0bdb4dd6de182919b109a16956605fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172d9238495284d49a34332143ad28c1"><td class="memItemLeft" align="right" valign="top">constexpr out&lt; details::out_type_print &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">print</a> () noexcept</td></tr>
<tr class="memdesc:a172d9238495284d49a34332143ad28c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; does not print a label and does not accept a debug level (as it cannot be turned off). All output is redirected to bsl::details::putc_stdout and bsl::details::puts_stdout. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples.  <a href="#a172d9238495284d49a34332143ad28c1">More...</a><br /></td></tr>
<tr class="separator:a172d9238495284d49a34332143ad28c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a9c10ac4501e78b4a7ea9c14c52b4"><td class="memTemplParams" colspan="2">template&lt;bsl::uintmax DL = 0&gt; </td></tr>
<tr class="memitem:a0b4a9c10ac4501e78b4a7ea9c14c52b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a75f7c17739499d031008ba99fed3a0b9">out_t</a>&lt; DL, details::out_type_debug &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0b4a9c10ac4501e78b4a7ea9c14c52b4">debug</a> () noexcept</td></tr>
<tr class="memdesc:a0b4a9c10ac4501e78b4a7ea9c14c52b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints "DEBUG: " when created and accepts a debug level, allowing it to be disabled. All output is redirected to bsl::details::putc_stdout and bsl::details::puts_stdout. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples.  <a href="#a0b4a9c10ac4501e78b4a7ea9c14c52b4">More...</a><br /></td></tr>
<tr class="separator:a0b4a9c10ac4501e78b4a7ea9c14c52b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cfc8786fe5806f3f16b8d7ebbc454a"><td class="memTemplParams" colspan="2">template&lt;bsl::uintmax DL = 0&gt; </td></tr>
<tr class="memitem:ad9cfc8786fe5806f3f16b8d7ebbc454a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a75f7c17739499d031008ba99fed3a0b9">out_t</a>&lt; DL, details::out_type_alert &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad9cfc8786fe5806f3f16b8d7ebbc454a">alert</a> () noexcept</td></tr>
<tr class="memdesc:ad9cfc8786fe5806f3f16b8d7ebbc454a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints "ALERT: " when created and accepts a debug level, allowing it to be disabled. All output is redirected to bsl::details::putc_stderr and bsl::details::puts_stderr. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples.  <a href="#ad9cfc8786fe5806f3f16b8d7ebbc454a">More...</a><br /></td></tr>
<tr class="separator:ad9cfc8786fe5806f3f16b8d7ebbc454a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1750b0ffee1ea6581fc7935148c75e"><td class="memItemLeft" align="right" valign="top">constexpr out&lt; details::out_type_error &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a6e1750b0ffee1ea6581fc7935148c75e">error</a> () noexcept</td></tr>
<tr class="memdesc:a6e1750b0ffee1ea6581fc7935148c75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints "ERROR: " when created and does not accept a debug level (as it cannot be turned off). All output is redirected to bsl::details::putc_stderr and bsl::details::puts_stderr. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples.  <a href="#a6e1750b0ffee1ea6581fc7935148c75e">More...</a><br /></td></tr>
<tr class="separator:a6e1750b0ffee1ea6581fc7935148c75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19e79c525543d028b9b0bdb56d022c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa19e79c525543d028b9b0bdb56d022c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a624d5ced1c693a5b7c74ac08f6a277b7">add_rvalue_reference_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa19e79c525543d028b9b0bdb56d022c1">declval</a> () noexcept</td></tr>
<tr class="memdesc:aa19e79c525543d028b9b0bdb56d022c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.  <a href="#aa19e79c525543d028b9b0bdb56d022c1">More...</a><br /></td></tr>
<tr class="separator:aa19e79c525543d028b9b0bdb56d022c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0738f2aff312d4abc46a43cfd2b61bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0738f2aff312d4abc46a43cfd2b61bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae0738f2aff312d4abc46a43cfd2b61bf">destroy_at</a> (T *const ptr) noexcept(noexcept(ptr-&gt;T::~T()))</td></tr>
<tr class="memdesc:ae0738f2aff312d4abc46a43cfd2b61bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the destructor of the object pointed to by ptr.  <a href="#ae0738f2aff312d4abc46a43cfd2b61bf">More...</a><br /></td></tr>
<tr class="separator:ae0738f2aff312d4abc46a43cfd2b61bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7b28ce6b0762c52732d1c00234efa4"><td class="memTemplParams" colspan="2">template&lt;typename... ARGS&gt; </td></tr>
<tr class="memitem:afa7b28ce6b0762c52732d1c00234efa4"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#afa7b28ce6b0762c52732d1c00234efa4">discard</a> (ARGS &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:afa7b28ce6b0762c52732d1c00234efa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function discards a parameter that it is given. This is the same as executing a static cast. The reason this exists is it better documents the intent to discard the result of a function or an intentionally unused parameter. This function also exists because in some cases, we must pass the address of a discard as as a template parameter, which cannot be done with a static cast.  <a href="#afa7b28ce6b0762c52732d1c00234efa4">More...</a><br /></td></tr>
<tr class="separator:afa7b28ce6b0762c52732d1c00234efa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23affe63d8ea654dc6f5cbdcd0762bb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = T&gt; </td></tr>
<tr class="memitem:a23affe63d8ea654dc6f5cbdcd0762bb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a23affe63d8ea654dc6f5cbdcd0762bb8">exchange</a> (T &amp;obj, U &amp;&amp;new_value) noexcept(false)</td></tr>
<tr class="memdesc:a23affe63d8ea654dc6f5cbdcd0762bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value of obj with new_value and returns the old value of obj.  <a href="#a23affe63d8ea654dc6f5cbdcd0762bb8">More...</a><br /></td></tr>
<tr class="separator:a23affe63d8ea654dc6f5cbdcd0762bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7462d3afecdac109000a17217ad2b63"><td class="memTemplParams" colspan="2">template&lt;typename VIEW , typename T &gt; </td></tr>
<tr class="memitem:ac7462d3afecdac109000a17217ad2b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a>&lt; <a class="el" href="classbsl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt; T &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac7462d3afecdac109000a17217ad2b63">fill</a> (VIEW &amp;vw, T const &amp;value) noexcept(//-- <a class="el" href="classbsl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt; T &gt;::value)</td></tr>
<tr class="memdesc:ac7462d3afecdac109000a17217ad2b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of a view to "value". T must be copy assignable.  <a href="#ac7462d3afecdac109000a17217ad2b63">More...</a><br /></td></tr>
<tr class="separator:ac7462d3afecdac109000a17217ad2b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca6ef8283c66b265b6554d366552f8f"><td class="memTemplParams" colspan="2">template&lt;typename ITER , typename T &gt; </td></tr>
<tr class="memitem:afca6ef8283c66b265b6554d366552f8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a>&lt; <a class="el" href="classbsl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt; T &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#afca6ef8283c66b265b6554d366552f8f">fill</a> (ITER first, ITER last, T const &amp;value) noexcept(//-- <a class="el" href="classbsl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt; T &gt;::value)</td></tr>
<tr class="memdesc:afca6ef8283c66b265b6554d366552f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of a view to "value". T must be copy assignable.  <a href="#afca6ef8283c66b265b6554d366552f8f">More...</a><br /></td></tr>
<tr class="separator:afca6ef8283c66b265b6554d366552f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153ba6e51aba9b91e4fa27c19c779fbe"><td class="memTemplParams" colspan="2">template&lt;typename... ARGS&gt; </td></tr>
<tr class="memitem:a153ba6e51aba9b91e4fa27c19c779fbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">for_each</a> (ARGS &amp;&amp;... args) noexcept(noexcept(//-- details::for_each_impl&lt; ARGS... &gt;::call(<a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt; ARGS &gt;(args)...)))</td></tr>
<tr class="memdesc:a153ba6e51aba9b91e4fa27c19c779fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops over a view or a pair of iterators, calling a provided function on each iteration. The provided function can take on the following signatures:  <a href="#a153ba6e51aba9b91e4fa27c19c779fbe">More...</a><br /></td></tr>
<tr class="separator:a153ba6e51aba9b91e4fa27c19c779fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f937baf04563f2ff88472912aa6148"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7f937baf04563f2ff88472912aa6148"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">forward</a> (<a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">bsl::remove_reference_t</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:ad7f937baf04563f2ff88472912aa6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">When "val" is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.  <a href="#ad7f937baf04563f2ff88472912aa6148">More...</a><br /></td></tr>
<tr class="separator:ad7f937baf04563f2ff88472912aa6148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ac15c7cd4e7dc7d1f05010923e6d8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ac15c7cd4e7dc7d1f05010923e6d8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad2ac15c7cd4e7dc7d1f05010923e6d8d">forward</a> (<a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">bsl::remove_reference_t</a>&lt; T &gt; &amp;&amp;val) noexcept</td></tr>
<tr class="memdesc:ad2ac15c7cd4e7dc7d1f05010923e6d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When "val" is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.  <a href="#ad2ac15c7cd4e7dc7d1f05010923e6d8d">More...</a><br /></td></tr>
<tr class="separator:ad2ac15c7cd4e7dc7d1f05010923e6d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6417bf1714ada612ce525074e8fab216"><td class="memTemplParams" colspan="2">template&lt;typename FUNC , typename... TN&gt; </td></tr>
<tr class="memitem:a6417bf1714ada612ce525074e8fab216"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a6417bf1714ada612ce525074e8fab216">invoke</a> (FUNC &amp;&amp;f, TN &amp;&amp;... tn) noexcept(//-- noexcept(details::invoke_impl&lt; FUNC, TN... &gt;::call(//-- <a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt; FUNC &gt;(f),//-- <a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt; TN &gt;(tn)...))) -&gt; decltype(details::invoke_impl&lt; FUNC, TN... &gt;::call(<a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt; FUNC &gt;(f), <a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt; TN &gt;(tn)...))</td></tr>
<tr class="memdesc:a6417bf1714ada612ce525074e8fab216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the callable object "f" with arguments "tn".  <a href="#a6417bf1714ada612ce525074e8fab216">More...</a><br /></td></tr>
<tr class="separator:a6417bf1714ada612ce525074e8fab216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb5763fa51693d9fc58d9b05b3f1697"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5fb5763fa51693d9fc58d9b05b3f1697">is_constant_evaluated</a> () noexcept</td></tr>
<tr class="memdesc:a5fb5763fa51693d9fc58d9b05b3f1697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.  <a href="#a5fb5763fa51693d9fc58d9b05b3f1697">More...</a><br /></td></tr>
<tr class="separator:a5fb5763fa51693d9fc58d9b05b3f1697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652cd6e0e849a63a02af84d7dde1910e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a652cd6e0e849a63a02af84d7dde1910e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a652cd6e0e849a63a02af84d7dde1910e">max_of</a> (T const &amp;a, T const &amp;b) noexcept</td></tr>
<tr class="memdesc:a652cd6e0e849a63a02af84d7dde1910e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a if a is larger than b, otherwise returns b. Note that this function is called max_of to prevent a name collision with <a class="el" href="classbsl_1_1numeric__limits.html#ae0401e964a70a2ccdabbe317e937506f" title="Returns the max value of T.">numeric_limits&lt;&gt;::max()</a>.  <a href="#a652cd6e0e849a63a02af84d7dde1910e">More...</a><br /></td></tr>
<tr class="separator:a652cd6e0e849a63a02af84d7dde1910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8a608775d9c674363cf30509ebf0ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c8a608775d9c674363cf30509ebf0ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2c8a608775d9c674363cf30509ebf0ba">min_of</a> (T const &amp;a, T const &amp;b) noexcept</td></tr>
<tr class="memdesc:a2c8a608775d9c674363cf30509ebf0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a if a is smaller than b, otherwise returns b. Note that this function is called min_of to prevent a name collision with <a class="el" href="classbsl_1_1numeric__limits.html#a5e1ccceb6ca44091c746559b84a022c8" title="Returns the min value of T.">numeric_limits&lt;&gt;::min()</a>.  <a href="#a2c8a608775d9c674363cf30509ebf0ba">More...</a><br /></td></tr>
<tr class="separator:a2c8a608775d9c674363cf30509ebf0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57197b06a4709af30ea016f2515a0ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac57197b06a4709af30ea016f2515a0ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">bsl::remove_reference_t</a>&lt; T &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac57197b06a4709af30ea016f2515a0ac">move</a> (T &amp;&amp;val) noexcept</td></tr>
<tr class="memdesc:ac57197b06a4709af30ea016f2515a0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that an object "val" may be "moved from", i.e. allowing the efficient transfer of resources from "val" to another object.  <a href="#ac57197b06a4709af30ea016f2515a0ac">More...</a><br /></td></tr>
<tr class="separator:ac57197b06a4709af30ea016f2515a0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2465a8dd3e8a52f1eea5759f3a2e5c85"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a2465a8dd3e8a52f1eea5759f3a2e5c85"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2465a8dd3e8a52f1eea5759f3a2e5c85">move</a> (<a class="el" href="classbsl_1_1fmt.html">fmt</a>&lt; V &gt; &amp;&amp;val) noexcept=delete</td></tr>
<tr class="memdesc:a2465a8dd3e8a52f1eea5759f3a2e5c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to prevent a move of <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> as it must always be a temporary r-value.  <a href="#a2465a8dd3e8a52f1eea5759f3a2e5c85">More...</a><br /></td></tr>
<tr class="separator:a2465a8dd3e8a52f1eea5759f3a2e5c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688150af052cb1e42d235e0e2a6677b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a688150af052cb1e42d235e0e2a6677b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a4f1cc2f9cd1ea0202b54f4237ecd1e66">conditional_t</a>&lt; !<a class="el" href="classbsl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="classbsl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt; T &gt;::value, T const &amp;, T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a688150af052cb1e42d235e0e2a6677b0">move_if_noexcept</a> (T &amp;val) noexcept</td></tr>
<tr class="memdesc:a688150af052cb1e42d235e0e2a6677b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">move_if_noexcept obtains an rvalue reference to its argument if its move constructor does not throw exceptions or if there is no copy constructor (move-only type), otherwise obtains an lvalue reference to its argument. It is typically used to combine move semantics with strong exception guarantee.  <a href="#a688150af052cb1e42d235e0e2a6677b0">More...</a><br /></td></tr>
<tr class="separator:a688150af052cb1e42d235e0e2a6677b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eb6fafedd79a63b6a389913b4e0111"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1source__location.html">source_location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac1eb6fafedd79a63b6a389913b4e0111">here</a> (<a class="el" href="classbsl_1_1source__location.html">source_location</a> const &amp;sloc=<a class="el" href="classbsl_1_1source__location.html#a4df3fd12670f7f63f0d782b35b48bf1d">source_location::current</a>()) noexcept</td></tr>
<tr class="memdesc:ac1eb6fafedd79a63b6a389913b4e0111"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a less verbose version of <a class="el" href="classbsl_1_1source__location.html#a4df3fd12670f7f63f0d782b35b48bf1d" title="Constructs a new source_location object corresponding to the location of the call site.">bsl::source_location::current()</a> to help reduce how large this code must be. They are equivalent, and should not produce any additional overhead in release mode.  <a href="#ac1eb6fafedd79a63b6a389913b4e0111">More...</a><br /></td></tr>
<tr class="separator:ac1eb6fafedd79a63b6a389913b4e0111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace538312ab16b685cfffc7eb75a1eb6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace538312ab16b685cfffc7eb75a1eb6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a>&lt; <a class="el" href="classbsl_1_1is__movable.html">is_movable</a>&lt; T &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ace538312ab16b685cfffc7eb75a1eb6a">swap</a> (T &amp;lhs, T &amp;rhs) noexcept(<a class="el" href="classbsl_1_1is__nothrow__movable.html">is_nothrow_movable</a>&lt; T &gt;::value)</td></tr>
<tr class="memdesc:ace538312ab16b685cfffc7eb75a1eb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the given values.  <a href="#ace538312ab16b685cfffc7eb75a1eb6a">More...</a><br /></td></tr>
<tr class="separator:ace538312ab16b685cfffc7eb75a1eb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad233c6ee9ead79f6164c3edb084ea82f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacebsl.html#aad5e36d8b13e4eb51b5c8d152cdcf9c6">bsl::exit_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad233c6ee9ead79f6164c3edb084ea82f">ut_success</a> () noexcept</td></tr>
<tr class="memdesc:ad233c6ee9ead79f6164c3edb084ea82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a message and returns <a class="el" href="namespacebsl.html#acff2a318fa459cacdca6e3eb53e52e2d" title="represents a successful exit">bsl::exit_success</a>.  <a href="#ad233c6ee9ead79f6164c3edb084ea82f">More...</a><br /></td></tr>
<tr class="separator:ad233c6ee9ead79f6164c3edb084ea82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2832d5c46b0c5a3072243e2df238f6"><td class="memItemLeft" align="right" valign="top"><a id="a1f2832d5c46b0c5a3072243e2df238f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1f2832d5c46b0c5a3072243e2df238f6">ut_check_failed</a> () noexcept</td></tr>
<tr class="memdesc:a1f2832d5c46b0c5a3072243e2df238f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a non-constexpr function that can be used to detect when a unit test check fails. If this function is called at compile-time, it will not compile, resulting in a human readable error message. <br /></td></tr>
<tr class="separator:a1f2832d5c46b0c5a3072243e2df238f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edde6206479f9456c6a2fa87782e55c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a1edde6206479f9456c6a2fa87782e55c">ut_check</a> (bool const test, <a class="el" href="namespacebsl.html#a5fefedc73c85f9a67d6028a786648e09">sloc_type</a> const &amp;sloc=<a class="el" href="namespacebsl.html#ac1eb6fafedd79a63b6a389913b4e0111">here</a>()) noexcept</td></tr>
<tr class="memdesc:a1edde6206479f9456c6a2fa87782e55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if "test" is true. If test is false, this function will exit fast with a failure code.  <a href="#a1edde6206479f9456c6a2fa87782e55c">More...</a><br /></td></tr>
<tr class="separator:a1edde6206479f9456c6a2fa87782e55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aab1dc53fc9256efe14abcd7b6e952f94"><td class="memItemLeft" align="right" valign="top"><a id="aab1dc53fc9256efe14abcd7b6e952f94"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aab1dc53fc9256efe14abcd7b6e952f94">errc_success</a> {0}</td></tr>
<tr class="memdesc:aab1dc53fc9256efe14abcd7b6e952f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the "no error" case. <br /></td></tr>
<tr class="separator:aab1dc53fc9256efe14abcd7b6e952f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf8c5f1eb4cf4b792013725ba6ba330"><td class="memItemLeft" align="right" valign="top"><a id="acaf8c5f1eb4cf4b792013725ba6ba330"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#acaf8c5f1eb4cf4b792013725ba6ba330">errc_failure</a> {1}</td></tr>
<tr class="memdesc:acaf8c5f1eb4cf4b792013725ba6ba330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the general unchecked error case. <br /></td></tr>
<tr class="separator:acaf8c5f1eb4cf4b792013725ba6ba330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98da7d312eabfb92b3ef8dbe98e652ff"><td class="memItemLeft" align="right" valign="top"><a id="a98da7d312eabfb92b3ef8dbe98e652ff"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a98da7d312eabfb92b3ef8dbe98e652ff">errc_precondition</a> {2}</td></tr>
<tr class="memdesc:a98da7d312eabfb92b3ef8dbe98e652ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the general precondition error case. <br /></td></tr>
<tr class="separator:a98da7d312eabfb92b3ef8dbe98e652ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe33db67ba4e5bd07b97b2a08f66aca9"><td class="memItemLeft" align="right" valign="top"><a id="abe33db67ba4e5bd07b97b2a08f66aca9"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#abe33db67ba4e5bd07b97b2a08f66aca9">errc_postcondition</a> {3}</td></tr>
<tr class="memdesc:abe33db67ba4e5bd07b97b2a08f66aca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the general postcondition error case. <br /></td></tr>
<tr class="separator:abe33db67ba4e5bd07b97b2a08f66aca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5a4a0bb32635232e89f2226b73b34d"><td class="memItemLeft" align="right" valign="top"><a id="aef5a4a0bb32635232e89f2226b73b34d"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aef5a4a0bb32635232e89f2226b73b34d">errc_assetion</a> {4}</td></tr>
<tr class="memdesc:aef5a4a0bb32635232e89f2226b73b34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the general assertion error case. <br /></td></tr>
<tr class="separator:aef5a4a0bb32635232e89f2226b73b34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bd1a46f73f421dc7f709337968929c"><td class="memItemLeft" align="right" valign="top"><a id="ae9bd1a46f73f421dc7f709337968929c"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae9bd1a46f73f421dc7f709337968929c">errc_invalid_argument</a> {10}</td></tr>
<tr class="memdesc:ae9bd1a46f73f421dc7f709337968929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an invalid argument error code. <br /></td></tr>
<tr class="separator:ae9bd1a46f73f421dc7f709337968929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbc50f0eeec17c42743d02b14e2ce26"><td class="memItemLeft" align="right" valign="top"><a id="a0dbc50f0eeec17c42743d02b14e2ce26"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0dbc50f0eeec17c42743d02b14e2ce26">errc_index_out_of_bounds</a> {11}</td></tr>
<tr class="memdesc:a0dbc50f0eeec17c42743d02b14e2ce26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an out of bounds error code. <br /></td></tr>
<tr class="separator:a0dbc50f0eeec17c42743d02b14e2ce26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6786477d6a486e12d22b7d9cb2ed4064"><td class="memItemLeft" align="right" valign="top"><a id="a6786477d6a486e12d22b7d9cb2ed4064"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a6786477d6a486e12d22b7d9cb2ed4064">errc_bad_function</a> {12}</td></tr>
<tr class="memdesc:a6786477d6a486e12d22b7d9cb2ed4064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an out of bounds error code. <br /></td></tr>
<tr class="separator:a6786477d6a486e12d22b7d9cb2ed4064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665e77c016b7e80845fd1995716ec190"><td class="memItemLeft" align="right" valign="top"><a id="a665e77c016b7e80845fd1995716ec190"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a665e77c016b7e80845fd1995716ec190">errc_unsigned_wrap</a> {30}</td></tr>
<tr class="memdesc:a665e77c016b7e80845fd1995716ec190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an overflow, underflow or unsigned wrap error. <br /></td></tr>
<tr class="separator:a665e77c016b7e80845fd1995716ec190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce8cc87d23318784f6c823e1201b2a8"><td class="memItemLeft" align="right" valign="top"><a id="a0ce8cc87d23318784f6c823e1201b2a8"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0ce8cc87d23318784f6c823e1201b2a8">errc_narrow_overflow</a> {31}</td></tr>
<tr class="memdesc:a0ce8cc87d23318784f6c823e1201b2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an overflow, underflow or unsigned wrap error. <br /></td></tr>
<tr class="separator:a0ce8cc87d23318784f6c823e1201b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa6d017cb3260ff90cc3a702780a16b"><td class="memItemLeft" align="right" valign="top"><a id="a4aa6d017cb3260ff90cc3a702780a16b"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a4aa6d017cb3260ff90cc3a702780a16b">errc_signed_overflow</a> {32}</td></tr>
<tr class="memdesc:a4aa6d017cb3260ff90cc3a702780a16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an overflow, underflow or unsigned wrap error. <br /></td></tr>
<tr class="separator:a4aa6d017cb3260ff90cc3a702780a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55709efeebed9bba17c3f2ac24d41e21"><td class="memItemLeft" align="right" valign="top"><a id="a55709efeebed9bba17c3f2ac24d41e21"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a55709efeebed9bba17c3f2ac24d41e21">errc_divide_by_zero</a> {33}</td></tr>
<tr class="memdesc:a55709efeebed9bba17c3f2ac24d41e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a divide by zero error. <br /></td></tr>
<tr class="separator:a55709efeebed9bba17c3f2ac24d41e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d60e99395faf640a054969bd463b08"><td class="memItemLeft" align="right" valign="top"><a id="ab5d60e99395faf640a054969bd463b08"></a>
constexpr <a class="el" href="classbsl_1_1basic__errc__type.html">basic_errc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab5d60e99395faf640a054969bd463b08">errc_nullptr_dereference</a> {34}</td></tr>
<tr class="memdesc:ab5d60e99395faf640a054969bd463b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an out of bounds error code. <br /></td></tr>
<tr class="separator:ab5d60e99395faf640a054969bd463b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee46080d6e64708dd37c82c49889f41"><td class="memItemLeft" align="right" valign="top"><a id="a8ee46080d6e64708dd37c82c49889f41"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a8ee46080d6e64708dd37c82c49889f41">reset_color</a> {&quot;\033[0m&quot;}</td></tr>
<tr class="memdesc:a8ee46080d6e64708dd37c82c49889f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the color output of debug statements <br /></td></tr>
<tr class="separator:a8ee46080d6e64708dd37c82c49889f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1a08255e830a89e1d27b540ebf3d0a"><td class="memItemLeft" align="right" valign="top"><a id="a5e1a08255e830a89e1d27b540ebf3d0a"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a5e1a08255e830a89e1d27b540ebf3d0a">black</a> {&quot;\033[0;90m&quot;}</td></tr>
<tr class="memdesc:a5e1a08255e830a89e1d27b540ebf3d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal black <br /></td></tr>
<tr class="separator:a5e1a08255e830a89e1d27b540ebf3d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33cfe7f9024aa63f8fb729d7ad3977f"><td class="memItemLeft" align="right" valign="top"><a id="ae33cfe7f9024aa63f8fb729d7ad3977f"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae33cfe7f9024aa63f8fb729d7ad3977f">red</a> {&quot;\033[0;91m&quot;}</td></tr>
<tr class="memdesc:ae33cfe7f9024aa63f8fb729d7ad3977f"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal red <br /></td></tr>
<tr class="separator:ae33cfe7f9024aa63f8fb729d7ad3977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb484fbd8fabdaf2a835da5795d524e"><td class="memItemLeft" align="right" valign="top"><a id="a6cb484fbd8fabdaf2a835da5795d524e"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a6cb484fbd8fabdaf2a835da5795d524e">green</a> {&quot;\033[0;92m&quot;}</td></tr>
<tr class="memdesc:a6cb484fbd8fabdaf2a835da5795d524e"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal green <br /></td></tr>
<tr class="separator:a6cb484fbd8fabdaf2a835da5795d524e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e436ca887d30513b158662b750fb4"><td class="memItemLeft" align="right" valign="top"><a id="a334e436ca887d30513b158662b750fb4"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a334e436ca887d30513b158662b750fb4">yellow</a> {&quot;\033[0;93m&quot;}</td></tr>
<tr class="memdesc:a334e436ca887d30513b158662b750fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal yellow <br /></td></tr>
<tr class="separator:a334e436ca887d30513b158662b750fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e15d634430c6f42b3fc0a8b230f3760"><td class="memItemLeft" align="right" valign="top"><a id="a8e15d634430c6f42b3fc0a8b230f3760"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a8e15d634430c6f42b3fc0a8b230f3760">blue</a> {&quot;\033[0;94m&quot;}</td></tr>
<tr class="memdesc:a8e15d634430c6f42b3fc0a8b230f3760"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal blue <br /></td></tr>
<tr class="separator:a8e15d634430c6f42b3fc0a8b230f3760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755405d0ce1e838df62ec1790bc77d6c"><td class="memItemLeft" align="right" valign="top"><a id="a755405d0ce1e838df62ec1790bc77d6c"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a755405d0ce1e838df62ec1790bc77d6c">magenta</a> {&quot;\033[0;95m&quot;}</td></tr>
<tr class="memdesc:a755405d0ce1e838df62ec1790bc77d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal magenta <br /></td></tr>
<tr class="separator:a755405d0ce1e838df62ec1790bc77d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c86e3d910814e0f714ebee3ab2773c"><td class="memItemLeft" align="right" valign="top"><a id="a12c86e3d910814e0f714ebee3ab2773c"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a12c86e3d910814e0f714ebee3ab2773c">cyan</a> {&quot;\033[0;96m&quot;}</td></tr>
<tr class="memdesc:a12c86e3d910814e0f714ebee3ab2773c"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal cyan <br /></td></tr>
<tr class="separator:a12c86e3d910814e0f714ebee3ab2773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0e9d907cc3b69d6c72e8b32cb0d543"><td class="memItemLeft" align="right" valign="top"><a id="abd0e9d907cc3b69d6c72e8b32cb0d543"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#abd0e9d907cc3b69d6c72e8b32cb0d543">white</a> {&quot;\033[0;97m&quot;}</td></tr>
<tr class="memdesc:abd0e9d907cc3b69d6c72e8b32cb0d543"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to normal white <br /></td></tr>
<tr class="separator:abd0e9d907cc3b69d6c72e8b32cb0d543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d53786d7f148737d849dc5e9ce8c6d"><td class="memItemLeft" align="right" valign="top"><a id="ab8d53786d7f148737d849dc5e9ce8c6d"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab8d53786d7f148737d849dc5e9ce8c6d">bold_black</a> {&quot;\033[1;90m&quot;}</td></tr>
<tr class="memdesc:ab8d53786d7f148737d849dc5e9ce8c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold black <br /></td></tr>
<tr class="separator:ab8d53786d7f148737d849dc5e9ce8c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a77210bdcf9980ab1aca23dc9ac0e36"><td class="memItemLeft" align="right" valign="top"><a id="a0a77210bdcf9980ab1aca23dc9ac0e36"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0a77210bdcf9980ab1aca23dc9ac0e36">bold_red</a> {&quot;\033[1;91m&quot;}</td></tr>
<tr class="memdesc:a0a77210bdcf9980ab1aca23dc9ac0e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold red <br /></td></tr>
<tr class="separator:a0a77210bdcf9980ab1aca23dc9ac0e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866b55e14233fa3d65d998dd68997aa6"><td class="memItemLeft" align="right" valign="top"><a id="a866b55e14233fa3d65d998dd68997aa6"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a866b55e14233fa3d65d998dd68997aa6">bold_green</a> {&quot;\033[1;92m&quot;}</td></tr>
<tr class="memdesc:a866b55e14233fa3d65d998dd68997aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold green <br /></td></tr>
<tr class="separator:a866b55e14233fa3d65d998dd68997aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de51e64e705db3b912304e5582849c2"><td class="memItemLeft" align="right" valign="top"><a id="a6de51e64e705db3b912304e5582849c2"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a6de51e64e705db3b912304e5582849c2">bold_yellow</a> {&quot;\033[1;93m&quot;}</td></tr>
<tr class="memdesc:a6de51e64e705db3b912304e5582849c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold yellow <br /></td></tr>
<tr class="separator:a6de51e64e705db3b912304e5582849c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fd08c66faa726bc87530c799757fe8"><td class="memItemLeft" align="right" valign="top"><a id="a89fd08c66faa726bc87530c799757fe8"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a89fd08c66faa726bc87530c799757fe8">bold_blue</a> {&quot;\033[1;94m&quot;}</td></tr>
<tr class="memdesc:a89fd08c66faa726bc87530c799757fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold blue <br /></td></tr>
<tr class="separator:a89fd08c66faa726bc87530c799757fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c5d3e8cb3e8788ecdbd3788bd9c888"><td class="memItemLeft" align="right" valign="top"><a id="ab9c5d3e8cb3e8788ecdbd3788bd9c888"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ab9c5d3e8cb3e8788ecdbd3788bd9c888">bold_magenta</a> {&quot;\033[1;95m&quot;}</td></tr>
<tr class="memdesc:ab9c5d3e8cb3e8788ecdbd3788bd9c888"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold magenta <br /></td></tr>
<tr class="separator:ab9c5d3e8cb3e8788ecdbd3788bd9c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9badcef038fce4cfea45fd5488e4e4f4"><td class="memItemLeft" align="right" valign="top"><a id="a9badcef038fce4cfea45fd5488e4e4f4"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a9badcef038fce4cfea45fd5488e4e4f4">bold_cyan</a> {&quot;\033[1;96m&quot;}</td></tr>
<tr class="memdesc:a9badcef038fce4cfea45fd5488e4e4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold cyan <br /></td></tr>
<tr class="separator:a9badcef038fce4cfea45fd5488e4e4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deb78f9db37fb49bd5489e2f46c9fff"><td class="memItemLeft" align="right" valign="top"><a id="a0deb78f9db37fb49bd5489e2f46c9fff"></a>
constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0deb78f9db37fb49bd5489e2f46c9fff">bold_white</a> {&quot;\033[1;97m&quot;}</td></tr>
<tr class="memdesc:a0deb78f9db37fb49bd5489e2f46c9fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the foreground color to bold white <br /></td></tr>
<tr class="separator:a0deb78f9db37fb49bd5489e2f46c9fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c468ef980d5578f2e9cc5a24207698"><td class="memItemLeft" align="right" valign="top"><a id="aa9c468ef980d5578f2e9cc5a24207698"></a>
constexpr <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#aa9c468ef980d5578f2e9cc5a24207698">v</a> {1U}</td></tr>
<tr class="memdesc:aa9c468ef980d5578f2e9cc5a24207698"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines "-v" verbose mode <br /></td></tr>
<tr class="separator:aa9c468ef980d5578f2e9cc5a24207698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd26344409b84262a3477c96679ab9d"><td class="memItemLeft" align="right" valign="top"><a id="adbd26344409b84262a3477c96679ab9d"></a>
constexpr <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#adbd26344409b84262a3477c96679ab9d">vv</a> {2U}</td></tr>
<tr class="memdesc:adbd26344409b84262a3477c96679ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines "-vv" verbose mode <br /></td></tr>
<tr class="separator:adbd26344409b84262a3477c96679ab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e8f1e69b8334bb3a027148eeef090"><td class="memItemLeft" align="right" valign="top"><a id="a547e8f1e69b8334bb3a027148eeef090"></a>
constexpr <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a547e8f1e69b8334bb3a027148eeef090">vvv</a> {3U}</td></tr>
<tr class="memdesc:a547e8f1e69b8334bb3a027148eeef090"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines "-vvv" verbose mode <br /></td></tr>
<tr class="separator:a547e8f1e69b8334bb3a027148eeef090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0411c0b3b03f8f6277e9237b0dcb2220"><td class="memItemLeft" align="right" valign="top"><a id="a0411c0b3b03f8f6277e9237b0dcb2220"></a>
constexpr <a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">bsl::char_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">endl</a> {'\n'}</td></tr>
<tr class="memdesc:a0411c0b3b03f8f6277e9237b0dcb2220"><td class="mdescLeft">&#160;</td><td class="mdescRight">newline constant <br /></td></tr>
<tr class="separator:a0411c0b3b03f8f6277e9237b0dcb2220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff2a318fa459cacdca6e3eb53e52e2d"><td class="memItemLeft" align="right" valign="top"><a id="acff2a318fa459cacdca6e3eb53e52e2d"></a>
constexpr <a class="el" href="namespacebsl.html#aad5e36d8b13e4eb51b5c8d152cdcf9c6">exit_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#acff2a318fa459cacdca6e3eb53e52e2d">exit_success</a> {0}</td></tr>
<tr class="memdesc:acff2a318fa459cacdca6e3eb53e52e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a successful exit <br /></td></tr>
<tr class="separator:acff2a318fa459cacdca6e3eb53e52e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13926e593b2b2140424f9f8ec43e4ae9"><td class="memItemLeft" align="right" valign="top"><a id="a13926e593b2b2140424f9f8ec43e4ae9"></a>
constexpr <a class="el" href="namespacebsl.html#aad5e36d8b13e4eb51b5c8d152cdcf9c6">exit_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a13926e593b2b2140424f9f8ec43e4ae9">exit_failure</a> {1}</td></tr>
<tr class="memdesc:a13926e593b2b2140424f9f8ec43e4ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a failed exit <br /></td></tr>
<tr class="separator:a13926e593b2b2140424f9f8ec43e4ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ddf119d79951ad04aed1ef0b614f80"><td class="memItemLeft" align="right" valign="top"><a id="ac7ddf119d79951ad04aed1ef0b614f80"></a>
constexpr <a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ac7ddf119d79951ad04aed1ef0b614f80">nullops</a> {&quot;&quot;}</td></tr>
<tr class="memdesc:ac7ddf119d79951ad04aed1ef0b614f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines no formatting. <br /></td></tr>
<tr class="separator:ac7ddf119d79951ad04aed1ef0b614f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366cbb1867cba4a8c8821cc419f682cc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a366cbb1867cba4a8c8821cc419f682cc">ptrops</a></td></tr>
<tr class="memdesc:a366cbb1867cba4a8c8821cc419f682cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines how to format a ptr like type.  <a href="#a366cbb1867cba4a8c8821cc419f682cc">More...</a><br /></td></tr>
<tr class="separator:a366cbb1867cba4a8c8821cc419f682cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66ccdf7a07b523f7ac2a1cf47643acc"><td class="memItemLeft" align="right" valign="top"><a id="ad66ccdf7a07b523f7ac2a1cf47643acc"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad66ccdf7a07b523f7ac2a1cf47643acc">for_each_break</a> {false}</td></tr>
<tr class="memdesc:ad66ccdf7a07b523f7ac2a1cf47643acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells a foreach to stop its execution (same as "break") <br /></td></tr>
<tr class="separator:ad66ccdf7a07b523f7ac2a1cf47643acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f2fad3a678973cef09c16eb11944af"><td class="memItemLeft" align="right" valign="top"><a id="ad6f2fad3a678973cef09c16eb11944af"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ad6f2fad3a678973cef09c16eb11944af">for_each_continue</a> {true}</td></tr>
<tr class="memdesc:ad6f2fad3a678973cef09c16eb11944af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells a foreach to continue its execution (same as "continue") <br /></td></tr>
<tr class="separator:ad6f2fad3a678973cef09c16eb11944af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64eadc3e172cb807384a588706002eb"><td class="memItemLeft" align="right" valign="top"><a id="ae64eadc3e172cb807384a588706002eb"></a>
constexpr <a class="el" href="classbsl_1_1in__place__t.html">in_place_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#ae64eadc3e172cb807384a588706002eb">in_place</a> {}</td></tr>
<tr class="memdesc:ae64eadc3e172cb807384a588706002eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduces the verbosity of <a class="el" href="classbsl_1_1in__place__t.html" title="bsl::in_place, bsl::in_place_type, and bsl::in_place_index are disambiguation tags that can be passed...">bsl::in_place_t</a> <br /></td></tr>
<tr class="separator:ae64eadc3e172cb807384a588706002eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4e3288a0e9ba033a48ba5e48b01ec7"><td class="memItemLeft" align="right" valign="top"><a id="a2f4e3288a0e9ba033a48ba5e48b01ec7"></a>
constexpr <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html#a2f4e3288a0e9ba033a48ba5e48b01ec7">npos</a> {<a class="el" href="classbsl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a>&gt;::max()}</td></tr>
<tr class="memdesc:a2f4e3288a0e9ba033a48ba5e48b01ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines npos <br /></td></tr>
<tr class="separator:a2f4e3288a0e9ba033a48ba5e48b01ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2020 Assured Information Security, Inc.</dd>
<dd>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</dd>
<dd>
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</dd>
<dd>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="acd32c87c9060b301047deb71f5b775e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd32c87c9060b301047deb71f5b775e9">&#9670;&nbsp;</a></span>char_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">bsl::char_type</a> = typedef char</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard Char Type. </p>
<p>SUPPRESSION: PRQA 2428 - false positive</p><ul>
<li>We suppress this because A3-9-1 is referring to integer types, not c-style strings. Within the BSL, the char_type is used to define a character in a C-style string, not as an integer type. Char for strings is allowed. </li>
</ul>

</div>
</div>
<a id="a0e0636b7a3243bed71b235bafacc7208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0636b7a3243bed71b235bafacc7208">&#9670;&nbsp;</a></span>cstr_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">bsl::cstr_type</a> = typedef char const *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-style string type. </p>
<p>SUPPRESSION: PRQA 2428 - false positive</p><ul>
<li>We suppress this because A3-9-1 is referring to integer types, not c-style strings. </li>
</ul>

</div>
</div>
<a id="a4e9190ab55dc7106ba972bcee4648ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9190ab55dc7106ba972bcee4648ef3">&#9670;&nbsp;</a></span>detected_or</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Default , template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebsl.html#a4e9190ab55dc7106ba972bcee4648ef3">bsl::detected_or</a> = typedef details::detector&lt;Default, void, Op, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template detected_or is an alias for an unspecified class type with two public member typedefs value_t and type, which are defined as follows: </p>
<ul>
<li>If the template-id OP&lt;ARGS...&gt; denotes a valid type, then value_t is an alias for <a class="el" href="namespacebsl.html#a5aa75d729f1e40765ab7e9b8fe327789" title="provides a bool_constant that represents &quot;true&quot;">bsl::true_type</a>, and type is an alias for OP&lt;ARGS...&gt;;</li>
<li>Otherwise, value_t is an alias for <a class="el" href="namespacebsl.html#a12a5338ec760fc73a47f2166e4d29546" title="provides a bool_constant that represents &quot;false&quot;">bsl::false_type</a> and type is an alias for DEFAULT. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af46da9d0f3a7e8f290422068efa9d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46da9d0f3a7e8f290422068efa9d726">&#9670;&nbsp;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacebsl.html#af46da9d0f3a7e8f290422068efa9d726">bsl::float_denorm_style</a> : <a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates subnormal values for floating points. </p>
<dl class="section note"><dt>Note</dt><dd>We do not support floating point numbers. This is only implemented for completeness. In most cases, if you attempt to use floating point numbers with the BSL, you will receive a compilation error. </dd></dl>

</div>
</div>
<a id="a485215e55d01b8cae1a82da0a286b91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485215e55d01b8cae1a82da0a286b91a">&#9670;&nbsp;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacebsl.html#a485215e55d01b8cae1a82da0a286b91a">bsl::float_round_style</a> : <a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates round styles for floating points. </p>
<dl class="section note"><dt>Note</dt><dd>We do not support floating point numbers. This is only implemented for completeness. In most cases, if you attempt to use floating point numbers with the BSL, you will receive a compilation error. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1606d20b803f9b7b2be5072df4028435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1606d20b803f9b7b2be5072df4028435">&#9670;&nbsp;</a></span>addressof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T* bsl::addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp; (i.e., this should be used to get the address of an object instead of using &amp; as that could be unsafe). </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_ADDRESSOF_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_ADDRESSOF_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="addressof_8hpp.html">bsl/addressof.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_addressof_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> <span class="keyword">const</span> mydata{};</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespacebsl.html#a1606d20b803f9b7b2be5072df4028435">bsl::addressof</a>(mydata) == &amp;mydata) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of object to get the address of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the object of type T to get the address of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the address of val </dd></dl>

</div>
</div>
<a id="aff0f5e6825e9000d5b4fa8dab99bf4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f5e6825e9000d5b4fa8dab99bf4ac">&#9670;&nbsp;</a></span>addressof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const* bsl::addressof </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents the user from getting an address to a const as that would allow you to get the address of an rvalue which could result in UB. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_ADDRESSOF_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_ADDRESSOF_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="addressof_8hpp.html">bsl/addressof.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_addressof_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> <span class="keyword">const</span> mydata{};</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespacebsl.html#a1606d20b803f9b7b2be5072df4028435">bsl::addressof</a>(mydata) == &amp;mydata) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of object to get the address of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the object of type T to get the address of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the address of val </dd></dl>

</div>
</div>
<a id="abe65822a59d3f1a702390d3c1b345230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe65822a59d3f1a702390d3c1b345230">&#9670;&nbsp;</a></span>as_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a1a151f8f27c4d3e44230d246481ffd29">add_const_t</a>&lt;T&gt;&amp; bsl::as_const </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms lvalue reference to const type of t. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_AS_CONST_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_AS_CONST_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="as__const_8hpp.html">bsl/as_const.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__same_8hpp.html">bsl/is_same.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    constexpr <span class="keywordtype">bool</span> example_as_const_var{};</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_as_const_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (is_same&lt;decltype(<a class="code" href="namespacebsl.html#abe65822a59d3f1a702390d3c1b345230">as_const</a>(example_as_const_var)), <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp;&gt;::value) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to form the lvalue reference to const of </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the object of type T to form the const lvalue reference of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Forms lvalue reference to const type of t </dd></dl>

</div>
</div>
<a id="a7fa398963dd4a1ea7499fb63a1313749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa398963dd4a1ea7499fb63a1313749">&#9670;&nbsp;</a></span>as_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bsl::as_const </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>const rvalue reference overload is deleted to disallow rvalue arguments </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_AS_CONST_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_AS_CONST_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="as__const_8hpp.html">bsl/as_const.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__same_8hpp.html">bsl/is_same.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    constexpr <span class="keywordtype">bool</span> example_as_const_var{};</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_as_const_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (is_same&lt;decltype(<a class="code" href="namespacebsl.html#abe65822a59d3f1a702390d3c1b345230">as_const</a>(example_as_const_var)), <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp;&gt;::value) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to form the lvalue reference to const of </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the object of type T to form the const lvalue reference of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d0251f0a23b36f18e62e91926bc931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d0251f0a23b36f18e62e91926bc931">&#9670;&nbsp;</a></span>construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bsl::construct_at </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a constexpr version of placement new. that can be used by BSL's APIs to support constexpr based APIs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of object to initialize </td></tr>
    <tr><td class="paramname">ARGS</td><td>the types of args to initialize T with </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to the object to initialize </td></tr>
    <tr><td class="paramname">args</td><td>the args to initialize T with</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if T throws during construction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ea1baadedc7f43c5f6aa4db5f9bae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ea1baadedc7f43c5f6aa4db5f9bae3">&#9670;&nbsp;</a></span>builtin_memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* bsl::builtin_memset </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a5a8dd72d0bd7a737bd6c5ffeb4b5b258">bsl::int8</a> const&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::memset with parameter checks. If dst is a nullptr, or count is 0, this function returns a nullptr without doing anything. </p>
<dl class="section note"><dt>Note</dt><dd>Clang currently does not have support for this function in constexpr logic.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the buffer to set to all 'ch' </td></tr>
    <tr><td class="paramname">ch</td><td>the value to set the provided buffer to </td></tr>
    <tr><td class="paramname">count</td><td>the total number of bytes to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same result as std::memset. </dd></dl>

</div>
</div>
<a id="a3198a0e407e0ca0f326c36746bc0dba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3198a0e407e0ca0f326c36746bc0dba5">&#9670;&nbsp;</a></span>builtin_memcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> bsl::builtin_memcmp </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::memcmp with parameter checks. If lhs, rhs are a nullptr, or count is 0, this function returns 0. </p>
<dl class="section note"><dt>Note</dt><dd>For now, this function is marked as a non-constexpr as there seems to be a bug in how this function is implemented by Clang with constexpr functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the comparison </td></tr>
    <tr><td class="paramname">count</td><td>the total number of bytes to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same result as std::memcmp. </dd></dl>

</div>
</div>
<a id="a1c6d7dbac3d1c7d2a70a8284ae996ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6d7dbac3d1c7d2a70a8284ae996ed4">&#9670;&nbsp;</a></span>builtin_strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> bsl::builtin_strncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::strncmp with parameter checks. If lhs, rhs are a nullptr, or count is 0, this function returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left hand side of the comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>the right hand side of the comparison </td></tr>
    <tr><td class="paramname">count</td><td>the total number of bytes to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same result as std::strncmp. </dd></dl>

</div>
</div>
<a id="adb26dc11b55d83f3215aa728c80128a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb26dc11b55d83f3215aa728c80128a9">&#9670;&nbsp;</a></span>builtin_strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> bsl::builtin_strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::strlen with parameter checks. If str is a nullptr, this returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a pointer to a string to get the length of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same result as std::strlen. </dd></dl>

</div>
</div>
<a id="ad0bdb4dd6de182919b109a16956605fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bdb4dd6de182919b109a16956605fa">&#9670;&nbsp;</a></span>builtin_strnchr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> bsl::builtin_strnchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a0e0636b7a3243bed71b235bafacc7208">cstr_type</a> const&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">char_type</a> const&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as std::strnchr with parameter checks. If str is a nullptr, or count is 0, this function returns a nullptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to search </td></tr>
    <tr><td class="paramname">ch</td><td>the character to look for. </td></tr>
    <tr><td class="paramname">count</td><td>the total number of character in str to search through </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same result as std::strnchr. </dd></dl>

</div>
</div>
<a id="a172d9238495284d49a34332143ad28c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172d9238495284d49a34332143ad28c1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr out&lt;details::out_type_print&gt; bsl::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; does not print a label and does not accept a debug level (as it cannot be turned off). All output is redirected to bsl::details::putc_stdout and bsl::details::puts_stdout. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_DEBUG_PRINT_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_DEBUG_PRINT_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_debug_print() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example message: &quot;</span> &lt;&lt; val &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Returns and instance of bsl::out&lt;T&gt; </dd></dl>

</div>
</div>
<a id="a0b4a9c10ac4501e78b4a7ea9c14c52b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a9c10ac4501e78b4a7ea9c14c52b4">&#9670;&nbsp;</a></span>debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bsl::uintmax DL = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a75f7c17739499d031008ba99fed3a0b9">out_t</a>&lt;DL, details::out_type_debug&gt; bsl::debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints "DEBUG: " when created and accepts a debug level, allowing it to be disabled. All output is redirected to bsl::details::putc_stdout and bsl::details::puts_stdout. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_DEBUG_DEBUG_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_DEBUG_DEBUG_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_debug_debug() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        <a class="code" href="namespacebsl.html#a0b4a9c10ac4501e78b4a7ea9c14c52b4">bsl::debug</a>() &lt;&lt; <span class="stringliteral">&quot;example message: &quot;</span> &lt;&lt; val &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Returns and instance of bsl::out&lt;T&gt; </dd></dl>

</div>
</div>
<a id="ad9cfc8786fe5806f3f16b8d7ebbc454a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cfc8786fe5806f3f16b8d7ebbc454a">&#9670;&nbsp;</a></span>alert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bsl::uintmax DL = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a75f7c17739499d031008ba99fed3a0b9">out_t</a>&lt;DL, details::out_type_alert&gt; bsl::alert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints "ALERT: " when created and accepts a debug level, allowing it to be disabled. All output is redirected to bsl::details::putc_stderr and bsl::details::puts_stderr. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_DEBUG_ALERT_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_DEBUG_ALERT_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_debug_alert() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        <a class="code" href="namespacebsl.html#ad9cfc8786fe5806f3f16b8d7ebbc454a">bsl::alert</a>() &lt;&lt; <span class="stringliteral">&quot;example message: &quot;</span> &lt;&lt; val &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Returns and instance of bsl::out&lt;T&gt; </dd></dl>

</div>
</div>
<a id="a6e1750b0ffee1ea6581fc7935148c75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1750b0ffee1ea6581fc7935148c75e">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr out&lt;details::out_type_error&gt; bsl::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns and instance of bsl::out&lt;T&gt;. This version of bsl::out&lt;T&gt; prints "ERROR: " when created and does not accept a debug level (as it cannot be turned off). All output is redirected to bsl::details::putc_stderr and bsl::details::puts_stderr. See <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> for formatting documentation and examples. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_DEBUG_ERROR_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_DEBUG_ERROR_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_debug_error() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val{42};</div><div class="line">        <a class="code" href="namespacebsl.html#a6e1750b0ffee1ea6581fc7935148c75e">bsl::error</a>() &lt;&lt; <span class="stringliteral">&quot;example message: &quot;</span> &lt;&lt; val &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Returns and instance of bsl::out&lt;T&gt; </dd></dl>

</div>
</div>
<a id="aa19e79c525543d028b9b0bdb56d022c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19e79c525543d028b9b0bdb56d022c1">&#9670;&nbsp;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a624d5ced1c693a5b7c74ac08f6a277b7">add_rvalue_reference_t</a>&lt;T&gt; bsl::declval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type T to get a reference type from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cannot be called and thus never returns a value. The return type is T&amp;&amp; unless T is (possibly cv-qualified) void, in which case the return type is T. </dd></dl>

</div>
</div>
<a id="ae0738f2aff312d4abc46a43cfd2b61bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0738f2aff312d4abc46a43cfd2b61bf">&#9670;&nbsp;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bsl::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the destructor of the object pointed to by ptr. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_DESTROY_AT_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_DESTROY_AT_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="destroy__at_8hpp.html">bsl/destroy_at.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;example_class_subclass.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_destroy_at_overview() noexcept</div><div class="line">    {</div><div class="line">        example_class_subclass myclass{};</div><div class="line">        <span class="keywordflow">if</span> (myclass.get()) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#ae0738f2aff312d4abc46a43cfd2b61bf">bsl::destroy_at</a>(&amp;myclass);</div><div class="line">        <span class="keywordflow">if</span> (!myclass.get()) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>SUPPRESSION: PRQA 4213 - false positive</p><ul>
<li>We suppress this because M7-1-2 states that a parameter should be marked as a pointer to const if the parameter is not modified. This class call's the pointer's destructor, and therefor cannot labeled as const.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>defines the type pointer to by ptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to the object to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if T throws during destruction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa7b28ce6b0762c52732d1c00234efa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7b28ce6b0762c52732d1c00234efa4">&#9670;&nbsp;</a></span>discard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bsl::discard </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function discards a parameter that it is given. This is the same as executing a static cast. The reason this exists is it better documents the intent to discard the result of a function or an intentionally unused parameter. This function also exists because in some cases, we must pass the address of a discard as as a template parameter, which cannot be done with a static cast. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_DISCARD_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_DISCARD_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discard_8hpp.html">bsl/discard.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_discard_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> val{};</div><div class="line">        <a class="code" href="namespacebsl.html#afa7b28ce6b0762c52732d1c00234efa4">bsl::discard</a>(val);</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>SUPPRESSION: PRQA 4050 - exception required</p><ul>
<li>We suppress this because M0-1-8 states that all functions marked as returning void must have external side effects, which this function does not. AUTOSAR allows the use of static_cast&lt;void&gt; to mark a parameter or return as unused which is all that this is doing in a less verbose, more self-documenting way.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ARGS</td><td>the types that define the provided arguments to ignore </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23affe63d8ea654dc6f5cbdcd0762bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23affe63d8ea654dc6f5cbdcd0762bb8">&#9670;&nbsp;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T bsl::exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value of obj with new_value and returns the old value of obj. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_EXCHANGE_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_EXCHANGE_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="exchange_8hpp.html">bsl/exchange.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_exchange_overview() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> <span class="keyword">const</span> val1{23};</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> <span class="keyword">const</span> val2{42};</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> var1{val1};</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> var2{val2};</div><div class="line">        var2 = <a class="code" href="namespacebsl.html#a23affe63d8ea654dc6f5cbdcd0762bb8">bsl::exchange</a>(var1, var2);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (val2 == var1) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (val1 == var2) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the obj being exchanged </td></tr>
    <tr><td class="paramname">U</td><td>the type that defines the new value for obj </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object whose value will be set to new_value </td></tr>
    <tr><td class="paramname">new_value</td><td>the new value to set the obj to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the old value of obj prior to the exchange</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if obj's move constructor or obj's copy/move assignment throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7462d3afecdac109000a17217ad2b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7462d3afecdac109000a17217ad2b63">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VIEW , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a>&lt;<a class="el" href="classbsl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value&gt; bsl::fill </td>
          <td>(</td>
          <td class="paramtype">VIEW &amp;&#160;</td>
          <td class="paramname"><em>vw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all elements of a view to "value". T must be copy assignable. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FILL_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FILL_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fill_8hpp.html">bsl/fill.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="array_8hpp.html">bsl/array.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">bsl/for_each.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fill_overview() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> val{1U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> size{42U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1array.html">bsl::array&lt;bsl::uintmax, size&gt;</a> arr{};</div><div class="line">        <a class="code" href="namespacebsl.html#ac7462d3afecdac109000a17217ad2b63">bsl::fill</a>(arr, val);</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> sum{};</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(arr, [&amp;sum](<span class="keyword">auto</span> <span class="keyword">const</span> &amp;e) <span class="keyword">mutable</span> noexcept {</div><div class="line">            sum += e;</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (size == sum) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the values being filled </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vw</td><td>the view to fill </td></tr>
    <tr><td class="paramname">value</td><td>the value to set the view's elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return's void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if the copy assignment of T throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afca6ef8283c66b265b6554d366552f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca6ef8283c66b265b6554d366552f8f">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITER , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a>&lt;<a class="el" href="classbsl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value&gt; bsl::fill </td>
          <td>(</td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all elements of a view to "value". T must be copy assignable. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FILL_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FILL_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fill_8hpp.html">bsl/fill.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="array_8hpp.html">bsl/array.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">bsl/for_each.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_fill_overview() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> val{1U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> size{42U};</div><div class="line"></div><div class="line">        <a class="code" href="classbsl_1_1array.html">bsl::array&lt;bsl::uintmax, size&gt;</a> arr{};</div><div class="line">        <a class="code" href="namespacebsl.html#ac7462d3afecdac109000a17217ad2b63">bsl::fill</a>(arr, val);</div><div class="line"></div><div class="line">        <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> sum{};</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(arr, [&amp;sum](<span class="keyword">auto</span> <span class="keyword">const</span> &amp;e) <span class="keyword">mutable</span> noexcept {</div><div class="line">            sum += e;</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (size == sum) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the values being filled </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the position to start the loop </td></tr>
    <tr><td class="paramname">last</td><td>the position to end the loop </td></tr>
    <tr><td class="paramname">value</td><td>the value to set the view's elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return's void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if the copy assignment of T throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a153ba6e51aba9b91e4fa27c19c779fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153ba6e51aba9b91e4fa27c19c779fbe">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bsl::for_each </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loops over a view or a pair of iterators, calling a provided function on each iteration. The provided function can take on the following signatures: </p>
<ul>
<li>void(T &amp;elem)</li>
<li>void(T &amp;elem, bsl::uintmax index)</li>
<li>bool(T &amp;elem)</li>
<li>bool(T &amp;elem, bsl::uintmax index) The boolean versions of this function allow you to return either <a class="el" href="namespacebsl.html#ad66ccdf7a07b523f7ac2a1cf47643acc" title="Tells a foreach to stop its execution (same as &quot;break&quot;)">bsl::for_each_break</a> (to break from the loop) or for_each_continue (to continue the loop). Note that if you are using the void versions of the loop, you can continue by simply returning. The bool versions are only needed if you need to break from the loop, in which case <a class="el" href="namespacebsl.html#ad6f2fad3a678973cef09c16eb11944af" title="Tells a foreach to continue its execution (same as &quot;continue&quot;)">bsl::for_each_continue</a> should be used to return from the function. In addition to the different function signatures that you can provide, you can also provide <a class="el" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe" title="Loops over a view or a pair of iterators, calling a provided function on each iteration....">bsl::for_each</a> with either a subclass of a bsl::view, or two iterators (a begin and end iterator), which will be used to perform the loop. The <a class="el" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe" title="Loops over a view or a pair of iterators, calling a provided function on each iteration....">bsl::for_each</a> function acts like a ranged for loop when given a subclass of a bsl::view, and acts like a traditional for loop when given two iterators. Note that you can use a reverse iterator to loop in reverse, and you can use the BSL specific iter() functions that allow you to create your own begin and end iterators so that you can control the position and number of elements the loop will perform. For more information, see the following example: <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FOREACH_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FOREACH_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">bsl/for_each.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string__view_8hpp.html">bsl/string_view.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_for_each_overview() noexcept</div><div class="line">    {</div><div class="line">        constexpr bsl::string_view msg{<span class="stringliteral">&quot;Hello&quot;</span>};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> i1{1U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#adf5cecf5ad79f6cbfc4c7ab77dc09ac9">bsl::uintmax</a> i4{4U};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#acd32c87c9060b301047deb71f5b775e9">char_type</a> co{<span class="charliteral">&#39;o&#39;</span>};</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 1:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg, [](<span class="keyword">auto</span> &amp;e) noexcept {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; e;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 2:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg, [](<span class="keyword">auto</span> &amp;e, <span class="keyword">auto</span> <span class="keyword">const</span> i) noexcept {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;element [&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] == &quot;</span> &lt;&lt; e &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 3:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg, [](<span class="keyword">auto</span> &amp;e) noexcept -&gt; <span class="keywordtype">bool</span> {</div><div class="line">            <span class="keywordflow">if</span> (co == e) {</div><div class="line">                <span class="keywordflow">return</span> <a class="code" href="namespacebsl.html#ad66ccdf7a07b523f7ac2a1cf47643acc">bsl::for_each_break</a>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; e;</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="namespacebsl.html#ad6f2fad3a678973cef09c16eb11944af">for_each_continue</a>;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 4:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg.begin(), msg.end(), [](<span class="keyword">auto</span> &amp;e) noexcept {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; e;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 5:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg.iter(i1), msg.iter(i4), [](<span class="keyword">auto</span> &amp;e) noexcept {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; e;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 6:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg.rbegin(), msg.rend(), [](<span class="keyword">auto</span> &amp;e) noexcept {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; e;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line"></div><div class="line">        <span class="comment">// ---------------------------------------------------------------------</span></div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;example 7:\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe">bsl::for_each</a>(msg.rbegin(), msg.rend(), [](<span class="keyword">auto</span> &amp;e, <span class="keyword">auto</span> <span class="keyword">const</span> i) noexcept {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;element [&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] == &quot;</span> &lt;&lt; e &lt;&lt; <a class="code" href="namespacebsl.html#a0411c0b3b03f8f6277e9237b0dcb2220">bsl::endl</a>;</div><div class="line">        });</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ARGS</td><td>the types of arguments passed to <a class="el" href="namespacebsl.html#a153ba6e51aba9b91e4fa27c19c779fbe" title="Loops over a view or a pair of iterators, calling a provided function on each iteration....">bsl::for_each</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>can either be a subclass of bsl::view and a lambda, or a pair of iterators and a lambda. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f937baf04563f2ff88472912aa6148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f937baf04563f2ff88472912aa6148">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp;&amp; bsl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">bsl::remove_reference_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When "val" is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FORWARD_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FORWARD_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="forward_8hpp.html">bsl/forward.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discard_8hpp.html">bsl/discard.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__lvalue__reference_8hpp.html">bsl/is_lvalue_reference.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="move_8hpp.html">bsl/move.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    constexpr <span class="keywordtype">bool</span></div><div class="line">    detector(T &amp;&amp;t) noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#afa7b28ce6b0762c52732d1c00234efa4">bsl::discard</a>(t);</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classbsl_1_1is__lvalue__reference.html">bsl::is_lvalue_reference</a>&lt;decltype(t)&gt;::value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    constexpr <span class="keywordtype">bool</span></div><div class="line">    forwarder(T &amp;&amp;t) noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> detector(bsl::forward&lt;T&gt;(t));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_forward_overview() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> <span class="keyword">const</span> val1{42};</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val2{val1};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (forwarder(val1)) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!forwarder(<a class="code" href="namespacebsl.html#ac57197b06a4709af30ea016f2515a0ac">bsl::move</a>(val2))) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>SUPPRESSION: PRQA 4624 - false positive</p><ul>
<li>We suppress this because A7-5-1 states that a function shall not return a pointer or reference to a parameter that is a const reference, and this is a false positive because this is the required definition for std::forward</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the value being forwarded </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value being forwarded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static_cast&lt;T &amp;&amp;&gt;(val) </dd></dl>

</div>
</div>
<a id="ad2ac15c7cd4e7dc7d1f05010923e6d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ac15c7cd4e7dc7d1f05010923e6d8d">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp;&amp; bsl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">bsl::remove_reference_t</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When "val" is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_FORWARD_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_FORWARD_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="forward_8hpp.html">bsl/forward.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discard_8hpp.html">bsl/discard.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__lvalue__reference_8hpp.html">bsl/is_lvalue_reference.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="move_8hpp.html">bsl/move.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    constexpr <span class="keywordtype">bool</span></div><div class="line">    detector(T &amp;&amp;t) noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#afa7b28ce6b0762c52732d1c00234efa4">bsl::discard</a>(t);</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classbsl_1_1is__lvalue__reference.html">bsl::is_lvalue_reference</a>&lt;decltype(t)&gt;::value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    constexpr <span class="keywordtype">bool</span></div><div class="line">    forwarder(T &amp;&amp;t) noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> detector(bsl::forward&lt;T&gt;(t));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_forward_overview() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> <span class="keyword">const</span> val1{42};</div><div class="line">        <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val2{val1};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (forwarder(val1)) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!forwarder(<a class="code" href="namespacebsl.html#ac57197b06a4709af30ea016f2515a0ac">bsl::move</a>(val2))) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>SUPPRESSION: PRQA 4624 - false positive</p><ul>
<li>We suppress this because A7-5-1 states that a function shall not return a pointer or reference to a parameter that is a const reference, and this is a false positive because this is the required definition for std::forward</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the value being forwarded </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value being forwarded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static_cast&lt;T &amp;&amp;&gt;(val) </dd></dl>

</div>
</div>
<a id="a6417bf1714ada612ce525074e8fab216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6417bf1714ada612ce525074e8fab216">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FUNC , typename... TN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bsl::invoke </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(details::invoke_impl&lt;FUNC, TN...&gt;::call(    
            <a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt;FUNC&gt;(f),                              
            <a class="el" href="namespacebsl.html#ad7f937baf04563f2ff88472912aa6148">bsl::forward</a>&lt;TN&gt;(tn)...))                           
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the callable object "f" with arguments "tn". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>the type that defines the function being called </td></tr>
    <tr><td class="paramname">TN</td><td>the types that define the arguments passed to the provided function when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a pointer to the function being called. </td></tr>
    <tr><td class="paramname">tn</td><td>the arguments passed to the function f when called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of calling "f" with "tn"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if the provided function throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb5763fa51693d9fc58d9b05b3f1697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb5763fa51693d9fc58d9b05b3f1697">&#9670;&nbsp;</a></span>is_constant_evaluated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bsl::is_constant_evaluated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_IS_CONSTANT_EVALUATED_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_IS_CONSTANT_EVALUATED_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__constant__evaluated_8hpp.html">bsl/is_constant_evaluated.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_is_constant_evaluated_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> constexpr (<a class="code" href="namespacebsl.html#a5fb5763fa51693d9fc58d9b05b3f1697">bsl::is_constant_evaluated</a>()) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="namespacebsl.html#a5fb5763fa51693d9fc58d9b05b3f1697">bsl::is_constant_evaluated</a>()) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </dd></dl>

</div>
</div>
<a id="a652cd6e0e849a63a02af84d7dde1910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652cd6e0e849a63a02af84d7dde1910e">&#9670;&nbsp;</a></span>max_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T const&amp; bsl::max_of </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a if a is larger than b, otherwise returns b. Note that this function is called max_of to prevent a name collision with <a class="el" href="classbsl_1_1numeric__limits.html#ae0401e964a70a2ccdabbe317e937506f" title="Returns the max value of T.">numeric_limits&lt;&gt;::max()</a>. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_MAX_OF_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_MAX_OF_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="max__of_8hpp.html">bsl/max_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_max_of_overview() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val1{23};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val2{42};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespacebsl.html#a652cd6e0e849a63a02af84d7dde1910e">bsl::max_of</a>(val1, val2) == val2) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type that defines both a and b </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first parameter to compare </td></tr>
    <tr><td class="paramname">b</td><td>the second parameter to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a if a is larger than b, otherwise returns b. </dd></dl>

</div>
</div>
<a id="a2c8a608775d9c674363cf30509ebf0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8a608775d9c674363cf30509ebf0ba">&#9670;&nbsp;</a></span>min_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T const&amp; bsl::min_of </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a if a is smaller than b, otherwise returns b. Note that this function is called min_of to prevent a name collision with <a class="el" href="classbsl_1_1numeric__limits.html#a5e1ccceb6ca44091c746559b84a022c8" title="Returns the min value of T.">numeric_limits&lt;&gt;::min()</a>. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_MIN_OF_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_MIN_OF_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="min__of_8hpp.html">bsl/min_of.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_min_of_overview() noexcept</div><div class="line">    {</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val1{23};</div><div class="line">        constexpr <a class="code" href="namespacebsl.html#ad7463e35f2d5163201b51201e7cc6e33">bsl::int32</a> val2{42};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespacebsl.html#a2c8a608775d9c674363cf30509ebf0ba">bsl::min_of</a>(val1, val2) == val1) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type that defines both a and b </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first parameter to compare </td></tr>
    <tr><td class="paramname">b</td><td>the second parameter to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a if a is smaller than b, otherwise returns b. </dd></dl>

</div>
</div>
<a id="ac57197b06a4709af30ea016f2515a0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57197b06a4709af30ea016f2515a0ac">&#9670;&nbsp;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#afb9d843459e2d510c4bab126a9dd251d">bsl::remove_reference_t</a>&lt;T&gt;&amp;&amp; bsl::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to indicate that an object "val" may be "moved from", i.e. allowing the efficient transfer of resources from "val" to another object. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_MOVE_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_MOVE_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="move_8hpp.html">bsl/move.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_move_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> val1{<span class="keyword">true</span>};</div><div class="line">        <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp;&amp;val2{<a class="code" href="namespacebsl.html#ac57197b06a4709af30ea016f2515a0ac">bsl::move</a>(val1)};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (val2) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>SUPPRESSION: PRQA 4624 - false positive</p><ul>
<li>We suppress this because A7-5-1 states that a function shall not return a pointer or reference to a parameter that is a const reference, and this is a false positive because this is the required definition for std::move</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the value being moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value being moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns an xvalue expression that identifies "val" </dd></dl>

</div>
</div>
<a id="a2465a8dd3e8a52f1eea5759f3a2e5c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2465a8dd3e8a52f1eea5759f3a2e5c85">&#9670;&nbsp;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bsl::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1fmt.html">fmt</a>&lt; V &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to prevent a move of <a class="el" href="classbsl_1_1fmt.html" title="The bsl::fmt implements a similar syntax to that of std::format, We adopt a similar approach with som...">bsl::fmt</a> as it must always be a temporary r-value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of value being formatted for output </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value being moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a688150af052cb1e42d235e0e2a6677b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688150af052cb1e42d235e0e2a6677b0">&#9670;&nbsp;</a></span>move_if_noexcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a4f1cc2f9cd1ea0202b54f4237ecd1e66">conditional_t</a>&lt; !<a class="el" href="classbsl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="classbsl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value, T const &amp;, T &amp;&amp;&gt; bsl::move_if_noexcept </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move_if_noexcept obtains an rvalue reference to its argument if its move constructor does not throw exceptions or if there is no copy constructor (move-only type), otherwise obtains an lvalue reference to its argument. It is typically used to combine move semantics with strong exception guarantee. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_MOVE_IF_NOEXCEPT_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_MOVE_IF_NOEXCEPT_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="move__if__noexcept_8hpp.html">bsl/move_if_noexcept.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_move_if_noexcept_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> val1{<span class="keyword">true</span>};</div><div class="line">        <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp;&amp;val2{<a class="code" href="namespacebsl.html#a688150af052cb1e42d235e0e2a6677b0">bsl::move_if_noexcept</a>(val1)};</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (val2) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the value being moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value being moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::move(val) or val, depending on exception guarantees. </dd></dl>

</div>
</div>
<a id="ac1eb6fafedd79a63b6a389913b4e0111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eb6fafedd79a63b6a389913b4e0111">&#9670;&nbsp;</a></span>here()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1source__location.html">source_location</a> bsl::here </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1source__location.html">source_location</a> const &amp;&#160;</td>
          <td class="paramname"><em>sloc</em> = <code><a class="el" href="classbsl_1_1source__location.html#a4df3fd12670f7f63f0d782b35b48bf1d">source_location::current</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This provides a less verbose version of <a class="el" href="classbsl_1_1source__location.html#a4df3fd12670f7f63f0d782b35b48bf1d" title="Constructs a new source_location object corresponding to the location of the call site.">bsl::source_location::current()</a> to help reduce how large this code must be. They are equivalent, and should not produce any additional overhead in release mode. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_SOURCE_LOCATION_HERE_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_SOURCE_LOCATION_HERE_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="source__location_8hpp.html">bsl/source_location.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_source_location_here() noexcept</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <a class="code" href="namespacebsl.html#ac1eb6fafedd79a63b6a389913b4e0111">bsl::here</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sloc</td><td>the <a class="el" href="classbsl_1_1source__location.html" title="This class implements the source_location specification that will eventually be included in C++20....">source_location</a> object corresponding to the location of the call site. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classbsl_1_1source__location.html" title="This class implements the source_location specification that will eventually be included in C++20....">source_location</a> object corresponding to the location of the call site. </dd></dl>

</div>
</div>
<a id="ace538312ab16b685cfffc7eb75a1eb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace538312ab16b685cfffc7eb75a1eb6a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#a06e50a30f5c124ac0c32689c90375333">enable_if_t</a>&lt;<a class="el" href="classbsl_1_1is__movable.html">is_movable</a>&lt;T&gt;::value&gt; bsl::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the given values. </p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef EXAMPLE_SWAP_OVERVIEW_HPP</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_SWAP_OVERVIEW_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="swap_8hpp.html">bsl/swap.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="debug_8hpp.html">bsl/debug.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacebsl.html">bsl</a></div><div class="line">{</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span></div><div class="line">    example_swap_overview() noexcept</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> val1{};</div><div class="line">        <span class="keywordtype">bool</span> val2{<span class="keyword">true</span>};</div><div class="line">        <a class="code" href="namespacebsl.html#ace538312ab16b685cfffc7eb75a1eb6a">bsl::swap</a>(val1, val2);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (val1) {</div><div class="line">            <a class="code" href="namespacebsl.html#a172d9238495284d49a34332143ad28c1">bsl::print</a>() &lt;&lt; <span class="stringliteral">&quot;success\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type that defines the values being swapped </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the value being swapped with rhs </td></tr>
    <tr><td class="paramname">rhs</td><td>the value being swapped with lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return's void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>if move construction or assignment of T throws </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad233c6ee9ead79f6164c3edb084ea82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad233c6ee9ead79f6164c3edb084ea82f">&#9670;&nbsp;</a></span>ut_success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacebsl.html#aad5e36d8b13e4eb51b5c8d152cdcf9c6">bsl::exit_code</a> bsl::ut_success </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs a message and returns <a class="el" href="namespacebsl.html#acff2a318fa459cacdca6e3eb53e52e2d" title="represents a successful exit">bsl::exit_success</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>returns <a class="el" href="namespacebsl.html#acff2a318fa459cacdca6e3eb53e52e2d" title="represents a successful exit">bsl::exit_success</a> </dd></dl>

</div>
</div>
<a id="a1edde6206479f9456c6a2fa87782e55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edde6206479f9456c6a2fa87782e55c">&#9670;&nbsp;</a></span>ut_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bsl::ut_check </td>
          <td>(</td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a5fefedc73c85f9a67d6028a786648e09">sloc_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>sloc</em> = <code><a class="el" href="namespacebsl.html#ac1eb6fafedd79a63b6a389913b4e0111">here</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if "test" is true. If test is false, this function will exit fast with a failure code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>if test is true, this function returns true. If test is false, this function will exit fast with a failure code. </td></tr>
    <tr><td class="paramname">sloc</td><td>used to identify the location in the unit test that a check failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns test </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a366cbb1867cba4a8c8821cc419f682cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366cbb1867cba4a8c8821cc419f682cc">&#9670;&nbsp;</a></span>ptrops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbsl_1_1fmt__options.html">fmt_options</a> bsl::ptrops</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        (<span class="keyword">sizeof</span>(<a class="code" href="namespacebsl.html#a4bbe4625bac9ffc4c32a6997534e939b">bsl::uintptr</a>) == <span class="keyword">sizeof</span>(<a class="code" href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a>)) ? <span class="stringliteral">&quot;#010x&quot;</span> : <span class="stringliteral">&quot;#018x&quot;</span>}</div><div class="ttc" id="namespacebsl_html_a4bbe4625bac9ffc4c32a6997534e939b"><div class="ttname"><a href="namespacebsl.html#a4bbe4625bac9ffc4c32a6997534e939b">bsl::uintptr</a></div><div class="ttdeci">::uintptr_t uintptr</div><div class="ttdoc">defines a unsigned integer the size of a void *</div><div class="ttdef"><b>Definition:</b> cstdint.hpp:92</div></div>
<div class="ttc" id="namespacebsl_html_a47c99409d2c9c075982db6a0cef56e8a"><div class="ttname"><a href="namespacebsl.html#a47c99409d2c9c075982db6a0cef56e8a">bsl::uint32</a></div><div class="ttdeci">::uint32_t uint32</div><div class="ttdoc">defines an 32bit unsigned integer</div><div class="ttdef"><b>Definition:</b> cstdint.hpp:49</div></div>
</div><!-- fragment -->
<p>defines how to format a ptr like type. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
