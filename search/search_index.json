{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bareflank Support Library A different view on Core Guideline Compliance The Bareflank Support Library (BSL) is a simple, header-only library that provides support for C++ Core Guideline Compliance. Similar to the goals of the Guideline Support Library (GSL) by Microsoft, the BSL aims to provide the facilities needed to ensure guideline compliance, while minimizing the need for verbosity. Quick start Get the latest version of the BSL from GitHub: 1 git clone https://github.com/bareflank/bsl Enjoy: 1 2 3 4 5 6 7 #include path/bsl.h auto main () - int { auto da = bsl :: make_dynarray int ( 42 ); }","title":"About"},{"location":"#a-different-view-on-core-guideline-compliance","text":"The Bareflank Support Library (BSL) is a simple, header-only library that provides support for C++ Core Guideline Compliance. Similar to the goals of the Guideline Support Library (GSL) by Microsoft, the BSL aims to provide the facilities needed to ensure guideline compliance, while minimizing the need for verbosity.","title":"A different view on Core Guideline Compliance"},{"location":"#quick-start","text":"Get the latest version of the BSL from GitHub: 1 git clone https://github.com/bareflank/bsl Enjoy: 1 2 3 4 5 6 7 #include path/bsl.h auto main () - int { auto da = bsl :: make_dynarray int ( 42 ); }","title":"Quick start"},{"location":"apis/","text":"Application Programming Interfaces (APIs) The following documents all of the APIs that the BSL provides. Contracts Dynamic Array Input File Array Contracts Like the Guideline Support Library, the BSL provides the following contract macros for validating the inputs and outputs of a function. 1 2 bfexpects ( test ) bfensures ( test ) For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 auto foo ( int val ) - int { bfexpects ( val = 0 ); int ret = 0 ; if ( val == 42 ) { ret = val ; } bfensures ( ret = 0 ); return ret ; } If the test case given to bfexpects () or bfensures () is found to be false, by default, nothing happens (the contract violation is ignored). To enable contract violations, you must first define the following: 1 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT By default, contract violations are ignored, even though they are enabled using the above definition. To detect contract violations, you must also tell the BSL how you wish to handle them. The two options are: 1 #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION which tells the BLS to throw an exception on contract violations while the following: 1 #define BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION tells the BLS to execute std :: terminate () on contract violations. Note The above definitions must be defined prior to including the BSL to ensure they function properly. Alternatively, you can define them on the command line. In addition to bfexpects () and bfensures () , the BSL also provides the following 1 2 bfexpects_if ( test , cond ) bfensures_if ( test , cond ) Both of these act the same as their non-if counterparts, with the addition of a conditional if statement that is removed when contract violations are disabled, ensuring the compiler doesn't inadvertently leave an if statement in the resulting code (e.g., when optimizations are disabled). The BSL also provides \"terminate\" versions of these functions as follows: 1 2 3 4 bfexpects_terminate ( test ) bfensures_terminate ( test ) bfexpects_if_terminate ( test , cond ) bfensures_if_terminate ( test , cond ) These versions always call std :: terminate () , even if contracts are told to throw on violations. This is helpful when a function must be labeled as noexcept , as any attempt to throw on a violation would call std :: terminate () anyways. If you wish to conditionally label a function as noexcept based on the contract violation policy, the BSL als provides the following macro: 1 BFNOEXCEPT If contracts are set to throw on violations, this macro is defined as empty, otherwise this macro is defined as noexcept . Dynamic Array The C++ Standard Library currently does not have support for dynamic arrays. The best options are: std :: vector std :: unique_ptr The std :: vector is likely the best option, with the downside that there is no ability to control the size of the internal memory that a std :: vector creates (the count based constructors only state the minimum size a std :: vector allocates, not the actual size), and a std :: vector will always value-initialize the memory it allocates. When working with really large buffers, this can be problematic. The std :: vector can also be copied, which could lead to accidental copies when moves are intended. Finally, the std :: vector uses the allocator model, which is not well suited for mapping operations (like mapping in memory or files). The std :: unique_ptr has an array type, and solves most of the above problems, but it is not Core Guideline Compliant, does not store the size of the array you allocate, and does not provide support for iterators, or other types of accessors like at () . The BSL dynamic array is modeled after the std :: unique_ptr with the following changes: The size of the array is stored along with the pointer. Empty base optimizations are still leveraged to ensure the minimal possible storage requirements (similar to a std :: unique_ptr ). The deleter is given both the pointer and the size, providing support for free () and unmap () style functions that require both the pointer and the size without the deleter having to duplicate this storage. Iterators are provided (random access), including support for ranged based for-loops. Accessors like front () , back () , [] and at () are provided along with some other convenience functions. Core Guideline compliance is an optional feature that can be enabled to ensure out-of-range errors are detectable. Our hope with this class is that it eliminates the need for a gsl :: span as currently, the main use case we have for a gsl :: span is when array types are allocated using std :: unique_ptr as most Standard Library containers already provide Core Guideline compliant mechanisms for accessing their contents. Todo Add support for reference and pointer style Deleters Add support for the , , = and = operators Add support for some missing gsl :: span constructors and helper style functions like subspan () so that if a gsl :: span is needed, this class can be used in its place using the nodelete Deleter. Add some additional fill() functions (an operator=() versions) to make it easier to work with the array. Template Parameters T The element type to store in the bsl :: dynarray . There are little to no restrictions on what type T can be. Deleter The deleter type the bsl :: dynarray should use to delete the array when the bsl :: dynarray loses scope. By default, the bsl :: dynarray provides a default deleter that calls delete [] . If a custom deleter is provided, it will be default constructed unless one of the l-value or r-value constructors are used to pass in a non-default constructed deleter. The requirements for the deleter depend on which constructor is used, but in general, the deleter should be nothrow movable. Warning We currently do not support reference or pointer Deleter types. Member Types value_type = T element_type = T index_type = std::size_t difference_type = std::ptrdiff_t reference = T const_reference = const T pointer = T * const_pointer = const T * deleter_type = Deleter const_deleter_type = const Deleter iterator = random_access_iterator const_iterator = random_access_iterator reverse_iterator = std::reverse_iterator const_reverse_iterator = std::reverse_iterator Member Functions dynarray() dynarray(pointer ptr, index_type count) dynarray(pointer ptr, index_type count, const deleter_type d) dynarray(pointer ptr, index_type count, deleter_type d) dynarray(dynarray u) ~dynarray() operator=(dynarray r) release() reset(pointer ptr, index_type count) reset(const std::pair info) swap(dynarray other) get() get_deleter() operator bool() operator[] at() front() back() data() begin() / cbegin() end() / cend() rbegin() / crbegin() rend() / crend() empty() size() / ssize() size_bytes() max_size() fill() make_dynarray() make_dynarray_default_init() operator==() / operator!=() operator () dynarray() 1 constexpr dynarray () noexcept ; Creates a default initialized bsl :: dynarray . When called, get () will return a null pointer, and size () will return 0. Parameters Not applicable Return Not applicable Contracts Expects None Ensures empty () == true Usage 1 auto a = bsl :: dynarray int (); dynarray(pointer ptr, index_type count) 1 explicit dynarray ( pointer ptr , index_type count ) BFNOEXCEPT ; Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 auto a = bsl :: dynarray int ( new int [ 1 ], 1 ); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations. dynarray(pointer ptr, index_type count, const deleter_type d) 1 2 explicit dynarray ( pointer ptr , index_type count , const deleter_type d ) BFNOEXCEPT ; Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. This version of the pointer/count constructor allows you to provide your own l-value deleter instead of the bsl :: dynarray default-initializing the deleter for you. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. deleter an l-value reference to a custom deleter. The bsl :: dynarray will create a copy of this deleter and use it to delete the pointer when the bsl :: dynarray loses scope. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 2 3 4 5 6 7 8 9 10 11 12 template typename T struct my_deleter { auto operator ()( T * ptr , size_t size ) - void { delete [] ptr ; } }; auto d = my_deleter int (); auto a = bsl :: dynarray int ( new int [ 1 ], 1 , d ); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations. dynarray(pointer ptr, index_type count, deleter_type d) 1 2 explicit dynarray ( pointer ptr , index_type count , deleter_type d ) BFNOEXCEPT Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T . When called, get () will return ptr and size () will return count. This version of the pointer/count constructor allows you to provide your own r-value deleter instead of the bsl :: dynarray default-initializing the deleter for you. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. deleter an r-value reference to a custom deleter. The bsl :: dynarray will move this deleter and use it to delete the pointer when the bsl :: dynarray loses scope. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 2 3 4 5 6 7 8 9 10 11 template typename T struct my_deleter { auto operator ()( T * ptr , size_t size ) - void { delete [] ptr ; } }; auto a = bsl :: dynarray int ( new int [ 1 ], 1 , my_deleter int ()); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations. dynarray(dynarray u) 1 explicit dynarray ( dynarray u ) noexcept Creates a bsl :: dynarray from another bsl :: dynarray using move semantics. This constructor ensures that u . empty () is true. Whether or not the newly constructed bsl :: dynarray is empty depends on whether or not u is empty at the time of the move. Parameters u a bsl :: dynarray to construct a new bsl :: dynarray from. Return Not applicable Contracts Expects None Ensures u . empty () == true Usage 1 2 auto a1 = bsl :: make_dynarray int ( 1 ); auto a2 = bsl :: dynarray int ( std :: move ( a1 )); ~dynarray() 1 ~ dynarray () If the bsl :: dynarray is valid (i.e., get () does not return a null pointer), the destructor will use the deleter to delete the array that it owns. Otherwise, this function has no affect. Parameters Not applicable Return Not applicable Contracts Expects None Ensures None operator=(dynarray r) 1 2 constexpr auto operator = ( dynarray r ) noexcept - dynarray Transfers ownership of a bsl :: dynarray to this bsl :: dynarray using move semantics. This assignment ensures that r . empty () is true. Whether or not the this bsl :: dynarray is empty depends on whether or not r is empty at the time of the move. If this bsl :: dynarray already owns an array, it will be deleted before the move takes place. Parameters r a bsl :: dynarray to transfer ownership from. Return * this Contracts Expects None Ensures r . empty () == true Usage 1 2 3 auto a1 = bsl :: make_dynarray int ( 1 ); auto a2 = bsl :: make_dynarray int ( 1 ); a2 = std :: move ( a1 ); release() 1 2 [[ nodiscard ]] constexpr auto release () noexcept - std :: pair pointer , index_type Transfers ownership of a bsl :: dynarray to the caller by returning a pointer to the array and the number of elements in the array. After the execution of this function, get () will return a null pointer and size () will return 0. Parameters Not applicable Return Returns a std :: pair pointer , index_type containing a pointer to the array and the number of elements in the array. Contracts Expects None Ensures get () == nullptr size () == 0 if ret.first == nullptr, ret.second == 0 if ret.first != nullptr, ret.second = 1 Usage 1 2 3 auto a = bsl :: make_dynarray int ( 1 ); auto p = a . release (); delete [] p . first ; reset(pointer ptr, index_type count) 1 2 3 4 5 constexpr auto reset ( pointer ptr = pointer (), index_type count = index_type () ) noexcept - void Transfers ownership of an array at ptr of size count from the caller to the bsl :: dynarray . If the bsl :: dynarray already owns an array, the old array is deleted using the Deleter before ownership is transferred. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. Return Not applicable Contracts Expects if ptr == nullptr, count == 0 if ptr != nullptr, count = 1 Ensures if ptr == nullptr, empty() == true if ptr != nullptr, empty() == false Usage 1 2 3 auto a = bsl :: make_dynarray int ( 1 ); auto p = a . release (); a . reset ( p . first , p . second ); reset(const std::pair info) 1 2 constexpr auto reset ( const std :: pair pointer , index_type info ) noexcept - void Equivalent to reset ( info . first , info . second ) Parameters info a std :: pair containing a pointer to the array (a continuous memory block) the bsl :: dynarray will manage and the number of elements in the array. If the default deleter is used, this memory must be allocated using the new [] operator. Note the count does not refer to the number of bytes, but rather the total number of elements. Return Not applicable Contracts Expects if info.first == nullptr, info.second == 0 if info.first != nullptr, info.second = 1 Ensures if info.first == nullptr, empty() == true if info.first != nullptr, empty() == false Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); a . reset ( a . release ()); swap(dynarray other) 1 2 constexpr auto swap ( dynarray other ) noexcept - void Swaps ownership of an array between other and this. Both arrays remain unaffected other than the ownership change. Parameters other the bsl :: dynarray swap ownership with. Return Not applicable Contracts Expects None Ensures None Usage 1 2 3 auto a1 = bsl :: make_dynarray int ( 1 ); auto a2 = bsl :: make_dynarray int ( 1 ); a1 . swap ( a2 ); get() 1 2 [[ nodiscard ]] constexpr auto get () const - pointer Returns a pointer to the array managed by this bsl :: dynarray . Parameters Not applicable Return Returns a pointer to the array managed by this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); auto p = a . get (); get_deleter() 1 2 3 4 5 [[ nodiscard ]] constexpr auto get_deleter () noexcept - deleter_type [[ nodiscard ]] constexpr auto get_deleter () const noexcept - const_deleter_type Returns an l-value reference to the Deleter that this bsl :: dynarray will use to delete the array that it manages. Since the bsl :: dynarray uses Empty Base Optimizations to reduce its overall size, it is likely that the returned reference is equivalent to #! c ++* this . Parameters Not applicable Return Returns an l-value reference to the Deleter that this bsl :: dynarray will use to delete the array that it manages. Contracts Expects None Ensures None Usage 1 2 3 4 auto a = bsl :: make_dynarray int ( 1 ); auto p = a . release (); auto d = a . get_deleter (); d ( p . first , p . second ); operator bool() 1 explicit operator bool () const noexcept Returns true when this bsl :: dynarray manages a valid array. While this is equivalent to get () != nullptr , this function ensures that if it returns true, size () = 1 and if it returns false, size () == 0 . Parameters Not applicable Return Returns true when this bsl :: dynarray manages a valid array. Contracts Expects None Ensures if get () == nullptr, size () == 0 if get () != nullptr, size () = 1 Usage 1 2 3 4 5 6 7 auto a = bsl :: make_dynarray int ( 1 ); if ( a ) { std :: cout dynarray is valid \\n ; } else { std :: cout dynarray is invalid \\n ; } operator[] 1 2 3 4 5 [[ nodiscard ]] constexpr auto operator []( index_type i ) - reference [[ nodiscard ]] constexpr auto operator []( index_type i ) const - const_reference Returns an l-value reference to the element at index_type i in the array managed by this bsl :: dynarray . Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, the execution of this function is undefined when a contract violation occurs (such as an out of range error). Parameters i The index of the element within the array that this bsl :: dynarray manages to return. Return Returns an l-value reference to the element at index_type i in the array managed by this bsl :: dynarray . Contracts Expects i size () Ensures None Usage 1 2 3 auto a = bsl :: make_dynarray int ( 1 ); a [ 0 ] = 42 ; a [ 1 ] = 23 ; // --- throws, calls std::terminate() or is undefined at() 1 2 3 4 5 [[ nodiscard ]] constexpr auto at ( index_type pos ) - reference [[ nodiscard ]] constexpr auto at ( index_type pos ) const - const_reference Returns an l-value reference to the element at index_type pos in the array managed by this bsl :: dynarray . This function will always throw a std :: out_of_range exception when the index_type pos is = size () . Parameters i The index of the element within the array that this bsl :: dynarray manages to return. Return Returns an l-value reference to the element at index_type i in the array managed by this bsl :: dynarray . Contracts Expects i size () Ensures None Usage 1 2 3 auto a = bsl :: make_dynarray int ( 1 ); a . at ( 0 ) = 42 ; a . at ( 1 ) = 23 ; // --- throws front() 1 2 3 4 5 [[ nodiscard ]] constexpr auto front () - reference [[ nodiscard ]] constexpr auto front () const - const_reference Returns an l-value reference to the element at the beginning of the array managed by this bsl :: dynarray . This is equivalent to [ 0 ] . Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, the execution of this function is undefined when a contract violation occurs (such as an out of range error). Parameters Not applicable Return Returns an l-value reference to the element at the beginning of the array managed by this bsl :: dynarray . Contracts Expects ! empty () Ensures None Usage 1 2 3 4 5 auto a1 = bsl :: make_dynarray int ( 1 ); a1 . front () = 42 ; auto a2 = bsl :: dynarray int (); a2 . front () = 42 ; // --- throws, calls std::terminate() or is undefined back() 1 2 3 4 5 [[ nodiscard ]] constexpr auto back () - reference [[ nodiscard ]] constexpr auto back () const - const_reference Returns an l-value reference to the element at the end of the array managed by this bsl :: dynarray . This is equivalent to [ size () - 1 ] . Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, the execution of this function is undefined when a contract violation occurs (such as an out of range error). Parameters Not applicable Return Returns an l-value reference to the element at the end of the array managed by this bsl :: dynarray . Contracts Expects ! empty () Ensures None Usage 1 2 3 4 5 auto a1 = bsl :: make_dynarray int ( 1 ); a1 . back () = 42 ; auto a2 = bsl :: dynarray int (); a2 . back () = 42 ; // --- throws, calls std::terminate() or is undefined data() 1 2 3 4 5 [[ nodiscard ]] constexpr auto data () noexcept - pointer [[ nodiscard ]] constexpr auto data () const noexcept - const_pointer Returns a pointer to the array managed by this bsl :: dynarray . Parameters Not applicable Return Returns a pointer to the array managed by this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); auto p = a . data (); begin() / cbegin() 1 2 3 4 5 6 7 8 [[ nodiscard ]] constexpr auto begin () noexcept - iterator [[ nodiscard ]] constexpr auto begin () const noexcept - const_iterator [[ nodiscard ]] constexpr auto cbegin () const noexcept - const_iterator Returns an iterator to the first element in the array managed by this bsl :: dynarray . Warning Iterators will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, iterators will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, dereferencing an iterator is undefined when a contract violation occurs (such as an out of range error). It should be noted that unlike a gsl :: span , iterators only check for contract violations when dereferencing. Arithmetic on an iterator (including moving an iterator well beyond the bounds of the array) has no affect until the iterator is finally dereferenced. Parameters Not applicable Return Returns an iterator to the first element in the array managed by this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 3 4 5 6 7 8 9 auto a = bsl :: make_dynarray int ( 42 ); for ( auto iter = a . begin (); iter != a . end (); iter ++ ) { * iter = 42 ; } for ( const auto elem : a ) { std :: cout elem \\n ; } end() / cend() 1 2 3 4 5 6 7 8 [[ nodiscard ]] constexpr auto end () noexcept - iterator [[ nodiscard ]] constexpr auto end () const noexcept - const_iterator [[ nodiscard ]] constexpr auto cend () const noexcept - const_iterator Returns an iterator to the element after the last element in the array managed by this bsl :: dynarray . Warning Iterators will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, iterators will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, dereferencing an iterator is undefined when a contract violation occurs (such as an out of range error). It should be noted that unlike a gsl :: span , iterators only check for contract violations when dereferencing. Arithmetic on an iterator (including moving an iterator well beyond the bounds of the array) has no affect until the iterator is finally dereferenced. Parameters Not applicable Return Returns an iterator to the element after the last element in the array managed by this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 3 4 5 6 7 8 9 auto a = bsl :: make_dynarray int ( 42 ); for ( auto iter = a . begin (); iter != a . end (); iter ++ ) { * iter = 42 ; } for ( const auto elem : a ) { std :: cout elem \\n ; } rbegin() / crbegin() 1 2 3 4 5 6 7 8 [[ nodiscard ]] constexpr auto rbegin () noexcept - reverse_iterator [[ nodiscard ]] constexpr auto rbegin () const noexcept - const_reverse_iterator [[ nodiscard ]] constexpr auto crbegin () const noexcept - const_reverse_iterator Returns a reverse iterator to the last element in the array managed by this bsl :: dynarray . Warning Iterators will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, iterators will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, dereferencing an iterator is undefined when a contract violation occurs (such as an out of range error). It should be noted that unlike a gsl :: span , iterators only check for contract violations when dereferencing. Arithmetic on an iterator (including moving an iterator well beyond the bounds of the array) has no affect until the iterator is finally dereferenced. Parameters Not applicable Return Returns a reverse iterator to the last element in the array managed by this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 3 4 5 auto a = bsl :: make_dynarray int ( 42 ); for ( auto iter = a . rbegin (); iter != a . rend (); iter ++ ) { * iter = 42 ; } rend() / crend() 1 2 3 4 5 6 7 8 [[ nodiscard ]] constexpr auto rend () noexcept - reverse_iterator [[ nodiscard ]] constexpr auto rend () const noexcept - const_reverse_iterator [[ nodiscard ]] constexpr auto crend () const noexcept - const_reverse_iterator Returns a reverse iterator to the element before the first element in the array managed by this bsl :: dynarray . Warning Iterators will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, iterators will call std :: terminate () when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION are defined. If neither of these cases are true, dereferencing an iterator is undefined when a contract violation occurs (such as an out of range error). It should be noted that unlike a gsl :: span , iterators only check for contract violations when dereferencing. Arithmetic on an iterator (including moving an iterator well beyond the bounds of the array) has no affect until the iterator is finally dereferenced. Parameters Not applicable Return Returns a reverse iterator to the element before the first element in the array managed by this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 3 4 5 auto a = bsl :: make_dynarray int ( 42 ); for ( auto iter = a . rbegin (); iter != a . rend (); iter ++ ) { * iter = 42 ; } empty() 1 2 [[ nodiscard ]] constexpr auto empty () const noexcept - bool Returns true when this bsl :: dynarray is empty. While this is equivalent to size () == 0 , this function ensures that if it returns true, get () == nullptr and if it returns false, get () != nullptr . Parameters Not applicable Return Returns true when this bsl :: dynarray is empty. Contracts Expects None Ensures if get () == nullptr, size () == 0 if get () != nullptr, size () = 1 Usage 1 2 3 4 5 6 7 8 auto a = bsl :: make_dynarray int ( 1 ); if ( a . empty ()) { std :: cout dynarray is empty \\n ; } else { std :: cout dynarray is not empty \\n ; } size() / ssize() 1 2 3 4 5 [[ nodiscard ]] constexpr auto size () const noexcept - index_type [[ nodiscard ]] constexpr auto ssize () const noexcept - difference_type Returns the number of elements in this bsl :: dynarray . Parameters Not applicable Return Returns the number of elements in this bsl :: dynarray . Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); std :: cout a . size () \\n ; size_bytes() 1 2 [[ nodiscard ]] constexpr auto size_bytes () const noexcept - index_type Returns the size of this bsl :: dynarray in bytes, not elements. This is equivalent to size () * sizeof T . Parameters Not applicable Return Returns the size of this bsl :: dynarray in bytes, not elements. Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); std :: cout a . size_bytes () \\n ; max_size() 1 2 [[ nodiscard ]] constexpr auto max_size () const noexcept - index_type Returns the max number of elements this bsl :: dynarray can store. This is equivalent to std :: numeric_limits difference_type :: max () / sizeof T ; Parameters Not applicable Return Returns the max number of elements this bsl :: dynarray can store. Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); std :: cout a . max_size () \\n ; fill() 1 2 constexpr auto fill ( const T value ) - void Value-initializes each element in the bsl :: dynarray by copying value. Todo Add some additional fill() functions (an operator=() versions) to make it easier to work with the array. Parameters value the value to copy into each element in the bsl :: dynarray . Return Not applicable Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); a . fill ( 42 ); make_dynarray() 1 2 template typename T constexpr auto make_dynarray ( size_t count ) - dynarray T Creates a bsl :: dynarray of size count using the new [] operator and the default deleter. In addition, each element in the bsl :: dynarray is value-initialized using T () . Tip Whenever possible bsl :: make_dynarray should be used instead of manually creating a bsl :: dynarray as this function ensures that the size of the array matches the memory allocated. Parameters count The total number of elements in the array to create. Return A bsl :: dynarray of size count. Contracts Expects count 0 Ensures None Usage 1 auto a = bsl :: make_dynarray int ( 42 ); make_dynarray_default_init() 1 2 template typename T constexpr auto make_dynarray_default_init ( size_t count ) - dynarray T Creates a bsl :: dynarray of size count using the new [] operator and the default deleter. In addition, each element in the bsl :: dynarray is default-initialized. Tip Whenever possible bsl :: make_dynarray_default_init should be used instead of manually creating a bsl :: dynarray as this function ensures that the size of the array matches the memory allocated. Parameters count The total number of elements in the array to create. Return A bsl :: dynarray of size count. Contracts Expects count 0 Ensures None Usage 1 auto a = bsl :: make_dynarray int ( 42 ); operator==() / operator!=() 1 2 3 4 5 6 7 template typename T1 , typename D1 , typename T2 , typename D2 constexpr bool operator == ( const bsl :: dynarray T1 , D1 lhs , const bsl :: dynarray T2 , D2 rhs ) template typename T1 , typename D1 , typename T2 , typename D2 constexpr bool operator != ( const bsl :: dynarray T1 , D1 lhs , const bsl :: dynarray T2 , D2 rhs ) Returns true if the lhs bsl :: dynarray and the rhs bsl :: dynarray are equal (and vice versa). A bsl :: dynarray is equal to another bsl :: dynarray if they are the same size, and each element in each bsl :: dynarray compares equal at the same position. Todo Add support for the , , = and = operators Parameters lhs A bsl :: dynarray to compare rhs A bsl :: dynarray to compare Return Returns true if the lhs bsl :: dynarray and the rhs bsl :: dynarray are equal (and vice versa). Contracts Expects None Ensures None Usage 1 2 3 4 5 6 7 8 9 auto a1 = bsl :: make_dynarray int ( 1 ); auto a2 = bsl :: make_dynarray int ( 42 ); if ( a1 == a2 ) { std :: cout lhs and rhs are equal \\n ; } else { std :: cout lhs and rhs are not equal \\n ; } operator () 1 2 3 template typename CharT , typename Traits , typename T , typename D std :: basic_ostream CharT , Traits operator ( std :: basic_ostream CharT , Traits os , const bsl :: dynarray T , D da ) Adds the bsl :: dynarray to the output stream. This is equivalent to os static_cast void * ( da . get ()) . Parameters os The output stream to add the bsl :: dynarray to. rhs The bsl :: dynarray to add to the output stream Return Returns an l-value reference to the output stream. Contracts Expects None Ensures None Usage 1 2 auto a = bsl :: make_dynarray int ( 1 ); std :: cout a \\n ; Input File Array C++ currently doesn't have a fast, simple method for reading in the entire contents of a file into an array. The best options are: std :: vector std :: unique_ptr In either case, likely the fastest method is to use std :: fstream to open a file and then load the std :: vector or std :: unique_ptr with the contents of the file using the read function. The problem with std :: vector is that you would have to create a value-initialized array of memory based on the size of the file, and then load that array with the file's contents. For large files this is problematic as this requires the use of value-initialization even though you are about to initialize the contents of the vector with the file's contents. You could use a std :: unique_ptr to overcome this problem, but the std :: unique_ptr doesn't store the file's size. The other issue is with the read () function that std :: fstream provides as this is not as fast as directly mapping the file using the operating system's mapping facilities. For large files, these mapping facilities make a big difference in performance. The bsl : ifarray attempts to solve these issues by: Using a bsl :: dynarray as the array type. Instead of using std :: fstream , the bsl :: ifarray uses the operating system's mapping functions to map in the file (read-only), providing the bsl :: dynarray with a pointer to the newly mapped file and a custom deleter that unmaps instead of deletes. Exposing all of the functionality of the bsl :: dynarray , providing a safe mechanism for working with the file. In Bareflank, we need a class like this as we work with really large files (e.g., virtual machine images which can be gigabytes in size), but in general, this type of class should be helpful for anyone that needs array style access to a file. Important The bsl :: ifarray inherits the bsl :: dynarray , providing access to all of the facilities that the bsl :: dynarray provides. This documentation only documents the functions unique to the bsl :: ifarray (e.g., the constructors). For more information about the APIs that the bsl :: dynarray provides in addition, please see the Dynamic Array APIs. Todo Add support bsl :: farray for read/write access Add support for bsl :: ofarray for write-only access Template Parameters T The element type used to access the file. This defaults to uint8_t. Member Types value_type = T element_type = T index_type = std::size_t difference_type = std::ptrdiff_t reference = T const_reference = const T pointer = T * const_pointer = const T * deleter_type = bsl::farray_deleter const_deleter_type = const bsl::farray_deleter iterator = random_access_iterator const_iterator = random_access_iterator reverse_iterator = std::reverse_iterator const_reverse_iterator = std::reverse_iterator Member Functions ifarray() ifarray(const std::string filename) ifarray() 1 constexpr ifarray () noexcept ; Creates a default initialized bsl :: ifarray . When called, get () will return a null pointer, and size () will return 0. Parameters Not applicable Return Not applicable Contracts Expects None Ensures empty () == true Usage 1 auto a = bsl :: ifarray (); ifarray(const std::string filename) 1 constexpr ifarray ( const std :: string filename ) noexcept ; Creates a bsl :: ifarray by opening the file using filename, and mapping the file using the operating system's mapping functions. This function will throw if the file cannot be opened or mapped. Important The file is opened as read-only. Parameters Not applicable Return Not applicable Contracts Expects None Ensures None Usage 1 auto a = bsl :: ifarray ( test.txt );","title":"APIs"},{"location":"apis/#contracts","text":"Like the Guideline Support Library, the BSL provides the following contract macros for validating the inputs and outputs of a function. 1 2 bfexpects ( test ) bfensures ( test ) For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 auto foo ( int val ) - int { bfexpects ( val = 0 ); int ret = 0 ; if ( val == 42 ) { ret = val ; } bfensures ( ret = 0 ); return ret ; } If the test case given to bfexpects () or bfensures () is found to be false, by default, nothing happens (the contract violation is ignored). To enable contract violations, you must first define the following: 1 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT By default, contract violations are ignored, even though they are enabled using the above definition. To detect contract violations, you must also tell the BSL how you wish to handle them. The two options are: 1 #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION which tells the BLS to throw an exception on contract violations while the following: 1 #define BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION tells the BLS to execute std :: terminate () on contract violations. Note The above definitions must be defined prior to including the BSL to ensure they function properly. Alternatively, you can define them on the command line. In addition to bfexpects () and bfensures () , the BSL also provides the following 1 2 bfexpects_if ( test , cond ) bfensures_if ( test , cond ) Both of these act the same as their non-if counterparts, with the addition of a conditional if statement that is removed when contract violations are disabled, ensuring the compiler doesn't inadvertently leave an if statement in the resulting code (e.g., when optimizations are disabled). The BSL also provides \"terminate\" versions of these functions as follows: 1 2 3 4 bfexpects_terminate ( test ) bfensures_terminate ( test ) bfexpects_if_terminate ( test , cond ) bfensures_if_terminate ( test , cond ) These versions always call std :: terminate () , even if contracts are told to throw on violations. This is helpful when a function must be labeled as noexcept , as any attempt to throw on a violation would call std :: terminate () anyways. If you wish to conditionally label a function as noexcept based on the contract violation policy, the BSL als provides the following macro: 1 BFNOEXCEPT If contracts are set to throw on violations, this macro is defined as empty, otherwise this macro is defined as noexcept .","title":"Contracts"},{"location":"apis/#dynamic-array","text":"The C++ Standard Library currently does not have support for dynamic arrays. The best options are: std :: vector std :: unique_ptr The std :: vector is likely the best option, with the downside that there is no ability to control the size of the internal memory that a std :: vector creates (the count based constructors only state the minimum size a std :: vector allocates, not the actual size), and a std :: vector will always value-initialize the memory it allocates. When working with really large buffers, this can be problematic. The std :: vector can also be copied, which could lead to accidental copies when moves are intended. Finally, the std :: vector uses the allocator model, which is not well suited for mapping operations (like mapping in memory or files). The std :: unique_ptr has an array type, and solves most of the above problems, but it is not Core Guideline Compliant, does not store the size of the array you allocate, and does not provide support for iterators, or other types of accessors like at () . The BSL dynamic array is modeled after the std :: unique_ptr with the following changes: The size of the array is stored along with the pointer. Empty base optimizations are still leveraged to ensure the minimal possible storage requirements (similar to a std :: unique_ptr ). The deleter is given both the pointer and the size, providing support for free () and unmap () style functions that require both the pointer and the size without the deleter having to duplicate this storage. Iterators are provided (random access), including support for ranged based for-loops. Accessors like front () , back () , [] and at () are provided along with some other convenience functions. Core Guideline compliance is an optional feature that can be enabled to ensure out-of-range errors are detectable. Our hope with this class is that it eliminates the need for a gsl :: span as currently, the main use case we have for a gsl :: span is when array types are allocated using std :: unique_ptr as most Standard Library containers already provide Core Guideline compliant mechanisms for accessing their contents. Todo Add support for reference and pointer style Deleters Add support for the , , = and = operators Add support for some missing gsl :: span constructors and helper style functions like subspan () so that if a gsl :: span is needed, this class can be used in its place using the nodelete Deleter. Add some additional fill() functions (an operator=() versions) to make it easier to work with the array. Template Parameters T The element type to store in the bsl :: dynarray . There are little to no restrictions on what type T can be. Deleter The deleter type the bsl :: dynarray should use to delete the array when the bsl :: dynarray loses scope. By default, the bsl :: dynarray provides a default deleter that calls delete [] . If a custom deleter is provided, it will be default constructed unless one of the l-value or r-value constructors are used to pass in a non-default constructed deleter. The requirements for the deleter depend on which constructor is used, but in general, the deleter should be nothrow movable. Warning We currently do not support reference or pointer Deleter types. Member Types value_type = T element_type = T index_type = std::size_t difference_type = std::ptrdiff_t reference = T const_reference = const T pointer = T * const_pointer = const T * deleter_type = Deleter const_deleter_type = const Deleter iterator = random_access_iterator const_iterator = random_access_iterator reverse_iterator = std::reverse_iterator const_reverse_iterator = std::reverse_iterator","title":"Dynamic Array"},{"location":"apis/#input-file-array","text":"C++ currently doesn't have a fast, simple method for reading in the entire contents of a file into an array. The best options are: std :: vector std :: unique_ptr In either case, likely the fastest method is to use std :: fstream to open a file and then load the std :: vector or std :: unique_ptr with the contents of the file using the read function. The problem with std :: vector is that you would have to create a value-initialized array of memory based on the size of the file, and then load that array with the file's contents. For large files this is problematic as this requires the use of value-initialization even though you are about to initialize the contents of the vector with the file's contents. You could use a std :: unique_ptr to overcome this problem, but the std :: unique_ptr doesn't store the file's size. The other issue is with the read () function that std :: fstream provides as this is not as fast as directly mapping the file using the operating system's mapping facilities. For large files, these mapping facilities make a big difference in performance. The bsl : ifarray attempts to solve these issues by: Using a bsl :: dynarray as the array type. Instead of using std :: fstream , the bsl :: ifarray uses the operating system's mapping functions to map in the file (read-only), providing the bsl :: dynarray with a pointer to the newly mapped file and a custom deleter that unmaps instead of deletes. Exposing all of the functionality of the bsl :: dynarray , providing a safe mechanism for working with the file. In Bareflank, we need a class like this as we work with really large files (e.g., virtual machine images which can be gigabytes in size), but in general, this type of class should be helpful for anyone that needs array style access to a file. Important The bsl :: ifarray inherits the bsl :: dynarray , providing access to all of the facilities that the bsl :: dynarray provides. This documentation only documents the functions unique to the bsl :: ifarray (e.g., the constructors). For more information about the APIs that the bsl :: dynarray provides in addition, please see the Dynamic Array APIs. Todo Add support bsl :: farray for read/write access Add support for bsl :: ofarray for write-only access Template Parameters T The element type used to access the file. This defaults to uint8_t. Member Types value_type = T element_type = T index_type = std::size_t difference_type = std::ptrdiff_t reference = T const_reference = const T pointer = T * const_pointer = const T * deleter_type = bsl::farray_deleter const_deleter_type = const bsl::farray_deleter iterator = random_access_iterator const_iterator = random_access_iterator reverse_iterator = std::reverse_iterator const_reverse_iterator = std::reverse_iterator","title":"Input File Array"},{"location":"contributing/","text":"TBD","title":"Contributing"},{"location":"examples/","text":"Examples The Bareflank Support Library provides some simple examples to demonstrate how to use the library. For a more complete understanding, please read the APIs documentation or take a look at the project's unit tests. Dynamic Array The BSL provides a new container type called the Dynamic Array or bsl :: dynarray . The dynarray is the combination of a std :: unique_ptr [] array type, a std :: array , and a gsl :: span . The goal of this type to provide an array type that owns the memory associated with the array, while at the same time, providing a C++ Core Guideline compliant interface for working with the array, something that std :: unique_ptr does not provide currently. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION #include bsl.h auto main () - int { try { auto da = bsl :: make_dynarray int ( 5 ); da [ 0 ] = 4 ; da [ 1 ] = 8 ; da [ 2 ] = 15 ; da [ 3 ] = 16 ; da [ 4 ] = 23 ; da [ 5 ] = 42 ; // -- throws } catch ( const std :: exception e ) { std :: cout error: e . what () \\n ; } } The two #define statements tells the BSL to ensure the BSL is guideline compliant (as this support can be disabled to improve performance if guideline compliance is not a concern), as well as to throw an exception if a contract violation occurs. By default, contract violations are ignored, but you can also configure them to terminate if desired. The bsl :: make_dynarray () function behaves the same as std :: make_unique () without the addition of [] , creating a bsl :: dynarray of a given size. Once a bsl :: dynarray is created, you can access it using the same APIs that a std :: array and gsl :: span provide. Since guideline compliance is enabled and told to throw on violations, the attempt to set the 6 th element in the array generates an exception. Input File Array The bsl :: ifarray is a bsl :: dynarray that maps a file given a file name. Like the std :: ifstream , the bsl :: ifarray unmaps the file once it loses scope. 1 2 3 4 5 6 7 8 9 10 11 #include bsl.h auto main () - int { for ( const auto c : bsl :: ifarray char ( FILENAME )) { std :: cout c ; } std :: cout \\n ; } Since the bsl :: dynarray provides a full implementation of a random access iterator, ranged for loops can be used to safely traverse the array as shown above.","title":"Examples"},{"location":"examples/#dynamic-array","text":"The BSL provides a new container type called the Dynamic Array or bsl :: dynarray . The dynarray is the combination of a std :: unique_ptr [] array type, a std :: array , and a gsl :: span . The goal of this type to provide an array type that owns the memory associated with the array, while at the same time, providing a C++ Core Guideline compliant interface for working with the array, something that std :: unique_ptr does not provide currently. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION #include bsl.h auto main () - int { try { auto da = bsl :: make_dynarray int ( 5 ); da [ 0 ] = 4 ; da [ 1 ] = 8 ; da [ 2 ] = 15 ; da [ 3 ] = 16 ; da [ 4 ] = 23 ; da [ 5 ] = 42 ; // -- throws } catch ( const std :: exception e ) { std :: cout error: e . what () \\n ; } } The two #define statements tells the BSL to ensure the BSL is guideline compliant (as this support can be disabled to improve performance if guideline compliance is not a concern), as well as to throw an exception if a contract violation occurs. By default, contract violations are ignored, but you can also configure them to terminate if desired. The bsl :: make_dynarray () function behaves the same as std :: make_unique () without the addition of [] , creating a bsl :: dynarray of a given size. Once a bsl :: dynarray is created, you can access it using the same APIs that a std :: array and gsl :: span provide. Since guideline compliance is enabled and told to throw on violations, the attempt to set the 6 th element in the array generates an exception.","title":"Dynamic Array"},{"location":"examples/#input-file-array","text":"The bsl :: ifarray is a bsl :: dynarray that maps a file given a file name. Like the std :: ifstream , the bsl :: ifarray unmaps the file once it loses scope. 1 2 3 4 5 6 7 8 9 10 11 #include bsl.h auto main () - int { for ( const auto c : bsl :: ifarray char ( FILENAME )) { std :: cout c ; } std :: cout \\n ; } Since the bsl :: dynarray provides a full implementation of a random access iterator, ranged for loops can be used to safely traverse the array as shown above.","title":"Input File Array"},{"location":"getting_started/","text":"Getting Started The Bareflank Support Library is a header only library, and as such, usage of this library is as simple as downloading and including the bsl . h header. Alternatively, this library support the use of find_package () and traditional installs. Installation To install the BSL onto your local system, run the following from a bash terminal to download the latest source code from GitHub: 1 2 git clone https://github.com/bareflank/bsl cd bsl Once you have the latest source code, the following can be run to perform an install: 1 2 cmake . sudo make install Alternatively, you can install the BSL into a custom prefix as follows: 1 2 cmake . -DCMAKE_INSTALL_PREFIX = prefix path sudo make install Usage The easiest way to use the BSL is to simply include it as follows: 1 #include path/bsl.h If the BSL is installed onto your local system or a custom prefix, you can use the BSL as the following: 1 #include bsl/bsl.h Finally, once compiled, you can use find_package () with CMake as follows: 1 2 3 4 5 6 7 8 cmake_minimum_required ( VERSION 3.13 ) project ( dynarray CXX ) find_package ( bsl ) set ( CMAKE_CXX_STANDARD 17 ) add_executable ( a.out main.cpp ) target_link_libraries ( a.out PRIVATE bsl ) And then include the BSL as follows: 1 #include bsl.h Compilation Options The BSL comes with both a set of examples as well as unit tests. By default, these are both built when running make . If you wish, you can turn these off as follows: 1 cmake . -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF By default, the tests and examples are built using Clang Tidy to ensure the BSL is statically analyzed during development. This too can be disabled using the following: 1 cmake . -DDISABLE_CLANG_TIDY = ON Dynamic analysis using Google's sanitizers can be enabled as follows: 1 cmake . -DCMAKE_BUILD_TYPE = ASAN or 1 cmake . -DCMAKE_BUILD_TYPE = UBSAN Build Targets In addition to the typical build targets that CMake already provides, the BSL also provides targets to format the source code as well as execute the provided unit tests if BUILD_TESTS=ON . To format the source code, Clang Format 8 or higher must be installed to execute the following 1 make format To run the unit tests, execute the following: 1 make unittests","title":"Getting Started"},{"location":"getting_started/#installation","text":"To install the BSL onto your local system, run the following from a bash terminal to download the latest source code from GitHub: 1 2 git clone https://github.com/bareflank/bsl cd bsl Once you have the latest source code, the following can be run to perform an install: 1 2 cmake . sudo make install Alternatively, you can install the BSL into a custom prefix as follows: 1 2 cmake . -DCMAKE_INSTALL_PREFIX = prefix path sudo make install","title":"Installation"},{"location":"getting_started/#usage","text":"The easiest way to use the BSL is to simply include it as follows: 1 #include path/bsl.h If the BSL is installed onto your local system or a custom prefix, you can use the BSL as the following: 1 #include bsl/bsl.h Finally, once compiled, you can use find_package () with CMake as follows: 1 2 3 4 5 6 7 8 cmake_minimum_required ( VERSION 3.13 ) project ( dynarray CXX ) find_package ( bsl ) set ( CMAKE_CXX_STANDARD 17 ) add_executable ( a.out main.cpp ) target_link_libraries ( a.out PRIVATE bsl ) And then include the BSL as follows: 1 #include bsl.h","title":"Usage"},{"location":"getting_started/#compilation-options","text":"The BSL comes with both a set of examples as well as unit tests. By default, these are both built when running make . If you wish, you can turn these off as follows: 1 cmake . -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF By default, the tests and examples are built using Clang Tidy to ensure the BSL is statically analyzed during development. This too can be disabled using the following: 1 cmake . -DDISABLE_CLANG_TIDY = ON Dynamic analysis using Google's sanitizers can be enabled as follows: 1 cmake . -DCMAKE_BUILD_TYPE = ASAN or 1 cmake . -DCMAKE_BUILD_TYPE = UBSAN","title":"Compilation Options"},{"location":"getting_started/#build-targets","text":"In addition to the typical build targets that CMake already provides, the BSL also provides targets to format the source code as well as execute the provided unit tests if BUILD_TESTS=ON . To format the source code, Clang Format 8 or higher must be installed to execute the following 1 make format To run the unit tests, execute the following: 1 make unittests","title":"Build Targets"},{"location":"help/","text":"TBD","title":"Help"},{"location":"license/","text":"License MIT License Copyright 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}