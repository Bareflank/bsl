{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bareflank Support Library A different view on Core Guideline Compliance The Bareflank Support Library (BSL) is a simple, header-only library that provides support for C++ Core Guideline Compliance. Similar to the goals of the Guideline Support Library (GSL) by Microsoft, the BSL aims to provide the facilities needed to ensure guideline compliance, while minimizing the need for verbosity. Quick start Get the latest version of the BSL from GitHub: 1 git clone https://github.com/bareflank/bsl Enjoy: 1 2 3 4 5 6 7 #include path/bsl.h auto main () - int { auto da = bsl :: make_dynarray int ( 42 ); }","title":"About"},{"location":"#bareflank-support-library","text":"","title":"Bareflank Support Library"},{"location":"#a-different-view-on-core-guideline-compliance","text":"The Bareflank Support Library (BSL) is a simple, header-only library that provides support for C++ Core Guideline Compliance. Similar to the goals of the Guideline Support Library (GSL) by Microsoft, the BSL aims to provide the facilities needed to ensure guideline compliance, while minimizing the need for verbosity.","title":"A different view on Core Guideline Compliance"},{"location":"#quick-start","text":"Get the latest version of the BSL from GitHub: 1 git clone https://github.com/bareflank/bsl Enjoy: 1 2 3 4 5 6 7 #include path/bsl.h auto main () - int { auto da = bsl :: make_dynarray int ( 42 ); }","title":"Quick start"},{"location":"apis/","text":"Application Programming Interfaces (APIs) The following documents all of the APIs that the BSL provides. BSL Contracts Like the Guideline Support Library, the BSL provides the following contract macros for validating the inputs and outputs of a function. 1 2 bfexpects ( test ) bfensures ( test ) For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 auto foo ( int val ) - int { bfexpects ( val = 0 ); int ret = 0 ; if ( val == 42 ) { ret = val ; } bfensures ( ret = 0 ); return ret ; } If the test case given to bfexpects () or bfensures () is found to be false, by default, nothing happens (the contract violation is ignored). To enable contract violations, you must first define the following: 1 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT By default, contract violations are ignored, even though they are enabled using the above definition. To detect contract violations, you must also tell the BSL how you wish to handle them. The two options are: 1 #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION which tells the BLS to throw an exception on contract violations while the following: 1 #define BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION tells the BLS to execute std :: terminate () on contract violations. Note The above definitions must be defined prior to including the BSL to ensure they function properly. Alternatively, you can define them on the command line. In addition to bfexpects () and bfensures () , the BSL also provides the following 1 2 bfexpects_if ( test , cond ) bfensures_if ( test , cond ) Both of these act the same as their non-if counterparts, with the addition of a conditional if statement that is removed when contract violations are disabled, ensuring the compiler doesn't inadvertently leave an if statement in the resulting code (e.g., when optimizations are disabled). The BSL also provides \"terminate\" versions of these functions as follows: 1 2 3 4 bfexpects_terminate ( test ) bfensures_terminate ( test ) bfexpects_if_terminate ( test , cond ) bfensures_if_terminate ( test , cond ) These versions always call std :: terminate () , even if contracts are told to throw on violations. This is helpful when a function must labeled as noexcept , as any attempt to throw on a violation would call std :: terminate () anyways. If you wish to conditionally label a function as noexcept based on the contract violation policy, the BSL als provides the following macro: 1 BFNOEXCEPT If contracts are set to throw on violations, this macro is defined as empty. If contracts are set to terminate on violations, this macro is defined as noexcept . This is helpful if you wish to throw exceptions while unit testing and call std::terminate() in \"Release\" mode, ensuring the full benefits of noexcept can still be realized. Dynamic Array The C++ Standard Library currently does not have support for dynamic arrays. Currently, the best options are: std :: vector std :: unique_ptr The std :: vector is likely the best option, with the downside that there is no ability to control the size of the internal memory that a std :: vector creates (the count based constructors only state the minimum size a std :: vector allocates, not the actual size), and a std :: vector will always value-initialize the memory it allocates. When working with really large buffers, this can be problematic. The std :: vector can also be copied, which could lead to accidental copies when moves are intended. Finally, the std :: vector uses the allocator model, which is not well suited for mapping operations (like mapping in memory or files). The std :: unique_ptr has an array type, and solves most of the above problems, but it is not Core Guideline Compliant, does not store the size of the array you allocate, and does not provide support for iterators, or other types of accessors like at () . The BSL dynamic array is modeled after the std :: unique_ptr with the following changes: - The size of the array is stored along with the pointer. Empty base optimizations are still leveraged to ensure the minimal possible size storage requirements (similar to a std :: unique_ptr ). - The deleter is given both the pointer and the size, providing support for free () and unmap () style functions that require both the pointer and the size without the deleter having to duplicate this storage. - Iterators are provided (random access), including support for ranged based for-loops. - Accessors like front () , back () , [] and at () are provided along with some other convenience functions. - Core Guideline compliance is an optional feature that can be enabled to ensure out-of-range errors are detectable. Template Parameters T The element type to store in the bsl :: dynarray . There are little to no restrictions on what type T can be. Deleter The deleter type the bsl :: dynarray should use to delete the array when the bsl :: dynarray loses scope. By default, the bsl :: dynarray provides a default deleter that calls delete [] . If a custom deleter is provided, it will be default constructed unless one of the l-value or r-value constructors are used to pass in a non-default constructed deleter. The requirements for the deleter depend on which constructor is used, but in general, the deleter should be nothrow movable. Warning We currently do not support reference or pointer Deleter types. Member Types value_type = T element_type = T index_type = std::size_t difference_type = std::ptrdiff_t reference = T const_reference = const T pointer = T * const_pointer = const T * deleter_type = Deleter const_deleter_type = const Deleter iterator = random_access_iterator const_iterator = random_access_iterator reverse_iterator = std::reverse_iterator const_reverse_iterator = std::reverse_iterator Default constructor 1 constexpr dynarray () noexcept ; Creates a default initialized bsl :: dynarray . When called, get () will return a null pointer, and size () will return 0. Parameters Not applicable Return Not applicable Contracts Expects None Ensures empty () == true Usage 1 auto a = bsl :: dynarray int (); Pointer/count constructor 1 explicit dynarray ( pointer ptr , index_type count ) BFNOEXCEPT ; Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 auto a = bsl :: dynarray int ( new int [ 1 ], 1 ); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations. Pointer/count constructor with custom l-value deleter 1 2 explicit dynarray ( pointer ptr , index_type count , const deleter_type d ) BFNOEXCEPT ; Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. This version of the pointer/count constructor allows you to provide your own l-value deleter instead of the bsl :: dynarray default-initializing the deleter for you. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. deleter an l-value reference to a custom deleter. The bsl :: dynarray will create a copy of this deleter and use it to delete the pointer when the bsl :: dynarray loses scope. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 2 3 4 5 6 7 8 9 10 11 12 template typename T struct my_deleter { auto operator ()( T * ptr , size_t size ) - void { delete [] ptr ; } }; auto d = my_deleter int (); auto a = bsl :: dynarray int ( new int [ 1 ], 1 , d ); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations. Pointer/count constructor with custom r-value deleter 1 2 explicit dynarray ( pointer ptr , index_type count , deleter_type d ) BFNOEXCEPT Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. This version of the pointer/count constructor allows you to provide your own r-value deleter instead of the bsl :: dynarray default-initializing the deleter for you. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. deleter an r-value reference to a custom deleter. The bsl :: dynarray will move this deleter and use it to delete the pointer when the bsl :: dynarray loses scope. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 2 3 4 5 6 7 8 9 10 11 template typename T struct my_deleter { auto operator ()( T * ptr , size_t size ) - void { delete [] ptr ; } }; auto a = bsl :: dynarray int ( new int [ 1 ], 1 , my_deleter int ()); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations. Move constructor 1 explicit dynarray ( dynarray u ) noexcept Creates a bsl :: dynarray from another bsl :: dynarray using move semantics. This constructor ensures that u . empty () is true. Whether or not the newly constructed bsl :: dynarray is empty depends on whether or not u is empty at the time of the move. Parameters u a bsl :: dynarray to construct a new bsl :: dynarray from. Return Not applicable Contracts Expects None Ensures u . empty () == true Usage 1 2 auto a1 = bsl :: dynarray int ( new int [ 1 ], 1 ); auto a2 = bsl :: dynarray int ( std :: move ( a1 )); Destructor 1 ~ dynarray () If the bsl :: dynarray is valid (i.e., get () does not return a null pointer), the destructor will use the deleter to delete the array that it owns. Otherwise, this function has no affect. Parameters Not applicable Return Not applicable Contracts Expects None Ensures None Usage 1 auto a = bsl :: dynarray int ( new int [ 1 ], 1 ); Move assignment 1 2 constexpr auto operator = ( dynarray r ) noexcept - dynarray Transfers ownership of a bsl :: dynarray to this bsl :: dynarray using move semantics. This assignment ensures that r . empty () is true. Whether or not the this bsl :: dynarray is empty depends on whether or not r is empty at the time of the move. If this bsl :: dynarray already owns an array, it will be deleted before the move takes place. Parameters r a bsl :: dynarray to transfer ownership from. Return Not applicable Contracts Expects None Ensures r . empty () == true Usage 1 2 3 auto a1 = bsl :: dynarray int ( new int [ 1 ], 1 ); auto a2 = bsl :: dynarray int ( new int [ 1 ], 1 ); a2 = std :: move ( a1 );","title":"APIs"},{"location":"apis/#application-programming-interfaces-apis","text":"The following documents all of the APIs that the BSL provides.","title":"Application Programming Interfaces (APIs)"},{"location":"apis/#bsl-contracts","text":"Like the Guideline Support Library, the BSL provides the following contract macros for validating the inputs and outputs of a function. 1 2 bfexpects ( test ) bfensures ( test ) For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 auto foo ( int val ) - int { bfexpects ( val = 0 ); int ret = 0 ; if ( val == 42 ) { ret = val ; } bfensures ( ret = 0 ); return ret ; } If the test case given to bfexpects () or bfensures () is found to be false, by default, nothing happens (the contract violation is ignored). To enable contract violations, you must first define the following: 1 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT By default, contract violations are ignored, even though they are enabled using the above definition. To detect contract violations, you must also tell the BSL how you wish to handle them. The two options are: 1 #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION which tells the BLS to throw an exception on contract violations while the following: 1 #define BAREFLANK_TERMINATE_ON_CONTRACT_VIOLATION tells the BLS to execute std :: terminate () on contract violations. Note The above definitions must be defined prior to including the BSL to ensure they function properly. Alternatively, you can define them on the command line. In addition to bfexpects () and bfensures () , the BSL also provides the following 1 2 bfexpects_if ( test , cond ) bfensures_if ( test , cond ) Both of these act the same as their non-if counterparts, with the addition of a conditional if statement that is removed when contract violations are disabled, ensuring the compiler doesn't inadvertently leave an if statement in the resulting code (e.g., when optimizations are disabled). The BSL also provides \"terminate\" versions of these functions as follows: 1 2 3 4 bfexpects_terminate ( test ) bfensures_terminate ( test ) bfexpects_if_terminate ( test , cond ) bfensures_if_terminate ( test , cond ) These versions always call std :: terminate () , even if contracts are told to throw on violations. This is helpful when a function must labeled as noexcept , as any attempt to throw on a violation would call std :: terminate () anyways. If you wish to conditionally label a function as noexcept based on the contract violation policy, the BSL als provides the following macro: 1 BFNOEXCEPT If contracts are set to throw on violations, this macro is defined as empty. If contracts are set to terminate on violations, this macro is defined as noexcept . This is helpful if you wish to throw exceptions while unit testing and call std::terminate() in \"Release\" mode, ensuring the full benefits of noexcept can still be realized.","title":"BSL Contracts"},{"location":"apis/#dynamic-array","text":"The C++ Standard Library currently does not have support for dynamic arrays. Currently, the best options are: std :: vector std :: unique_ptr The std :: vector is likely the best option, with the downside that there is no ability to control the size of the internal memory that a std :: vector creates (the count based constructors only state the minimum size a std :: vector allocates, not the actual size), and a std :: vector will always value-initialize the memory it allocates. When working with really large buffers, this can be problematic. The std :: vector can also be copied, which could lead to accidental copies when moves are intended. Finally, the std :: vector uses the allocator model, which is not well suited for mapping operations (like mapping in memory or files). The std :: unique_ptr has an array type, and solves most of the above problems, but it is not Core Guideline Compliant, does not store the size of the array you allocate, and does not provide support for iterators, or other types of accessors like at () . The BSL dynamic array is modeled after the std :: unique_ptr with the following changes: - The size of the array is stored along with the pointer. Empty base optimizations are still leveraged to ensure the minimal possible size storage requirements (similar to a std :: unique_ptr ). - The deleter is given both the pointer and the size, providing support for free () and unmap () style functions that require both the pointer and the size without the deleter having to duplicate this storage. - Iterators are provided (random access), including support for ranged based for-loops. - Accessors like front () , back () , [] and at () are provided along with some other convenience functions. - Core Guideline compliance is an optional feature that can be enabled to ensure out-of-range errors are detectable. Template Parameters T The element type to store in the bsl :: dynarray . There are little to no restrictions on what type T can be. Deleter The deleter type the bsl :: dynarray should use to delete the array when the bsl :: dynarray loses scope. By default, the bsl :: dynarray provides a default deleter that calls delete [] . If a custom deleter is provided, it will be default constructed unless one of the l-value or r-value constructors are used to pass in a non-default constructed deleter. The requirements for the deleter depend on which constructor is used, but in general, the deleter should be nothrow movable. Warning We currently do not support reference or pointer Deleter types. Member Types value_type = T element_type = T index_type = std::size_t difference_type = std::ptrdiff_t reference = T const_reference = const T pointer = T * const_pointer = const T * deleter_type = Deleter const_deleter_type = const Deleter iterator = random_access_iterator const_iterator = random_access_iterator reverse_iterator = std::reverse_iterator const_reverse_iterator = std::reverse_iterator","title":"Dynamic Array"},{"location":"apis/#default-constructor","text":"1 constexpr dynarray () noexcept ; Creates a default initialized bsl :: dynarray . When called, get () will return a null pointer, and size () will return 0. Parameters Not applicable Return Not applicable Contracts Expects None Ensures empty () == true Usage 1 auto a = bsl :: dynarray int ();","title":"Default constructor"},{"location":"apis/#pointercount-constructor","text":"1 explicit dynarray ( pointer ptr , index_type count ) BFNOEXCEPT ; Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 auto a = bsl :: dynarray int ( new int [ 1 ], 1 ); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations.","title":"Pointer/count constructor"},{"location":"apis/#pointercount-constructor-with-custom-l-value-deleter","text":"1 2 explicit dynarray ( pointer ptr , index_type count , const deleter_type d ) BFNOEXCEPT ; Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. This version of the pointer/count constructor allows you to provide your own l-value deleter instead of the bsl :: dynarray default-initializing the deleter for you. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. deleter an l-value reference to a custom deleter. The bsl :: dynarray will create a copy of this deleter and use it to delete the pointer when the bsl :: dynarray loses scope. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 2 3 4 5 6 7 8 9 10 11 12 template typename T struct my_deleter { auto operator ()( T * ptr , size_t size ) - void { delete [] ptr ; } }; auto d = my_deleter int (); auto a = bsl :: dynarray int ( new int [ 1 ], 1 , d ); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations.","title":"Pointer/count constructor with custom l-value deleter"},{"location":"apis/#pointercount-constructor-with-custom-r-value-deleter","text":"1 2 explicit dynarray ( pointer ptr , index_type count , deleter_type d ) BFNOEXCEPT Creates a value initialized bsl :: dynarray that owns an array at ptr, of count elements of T. When called, get () will return ptr and size () will return count. This version of the pointer/count constructor allows you to provide your own r-value deleter instead of the bsl :: dynarray default-initializing the deleter for you. Parameters ptr a pointer to the array (a continuous memory block) the bsl :: dynarray will manage. If the default deleter is used, this memory must be allocated using the new [] operator. count the number of elements in the array. Note the count does not refer to the number of bytes, but rather the total number of elements. deleter an r-value reference to a custom deleter. The bsl :: dynarray will move this deleter and use it to delete the pointer when the bsl :: dynarray loses scope. Return Not applicable Contracts Expects ptr must not be a null pointer count must be larger than 0. Ensures empty () == false Usage 1 2 3 4 5 6 7 8 9 10 11 template typename T struct my_deleter { auto operator ()( T * ptr , size_t size ) - void { delete [] ptr ; } }; auto a = bsl :: dynarray int ( new int [ 1 ], 1 , my_deleter int ()); Warning This function will throw when both BAREFLANK_CORE_GUIDELINE_COMPLIANT and BAREFLANK_THROW_ON_CONTRACT_VIOLATION are defined prior to including the BSL when a contract violation occurs. Otherwise, this function will call std :: terminate () on such violations.","title":"Pointer/count constructor with custom r-value deleter"},{"location":"apis/#move-constructor","text":"1 explicit dynarray ( dynarray u ) noexcept Creates a bsl :: dynarray from another bsl :: dynarray using move semantics. This constructor ensures that u . empty () is true. Whether or not the newly constructed bsl :: dynarray is empty depends on whether or not u is empty at the time of the move. Parameters u a bsl :: dynarray to construct a new bsl :: dynarray from. Return Not applicable Contracts Expects None Ensures u . empty () == true Usage 1 2 auto a1 = bsl :: dynarray int ( new int [ 1 ], 1 ); auto a2 = bsl :: dynarray int ( std :: move ( a1 ));","title":"Move constructor"},{"location":"apis/#destructor","text":"1 ~ dynarray () If the bsl :: dynarray is valid (i.e., get () does not return a null pointer), the destructor will use the deleter to delete the array that it owns. Otherwise, this function has no affect. Parameters Not applicable Return Not applicable Contracts Expects None Ensures None Usage 1 auto a = bsl :: dynarray int ( new int [ 1 ], 1 );","title":"Destructor"},{"location":"apis/#move-assignment","text":"1 2 constexpr auto operator = ( dynarray r ) noexcept - dynarray Transfers ownership of a bsl :: dynarray to this bsl :: dynarray using move semantics. This assignment ensures that r . empty () is true. Whether or not the this bsl :: dynarray is empty depends on whether or not r is empty at the time of the move. If this bsl :: dynarray already owns an array, it will be deleted before the move takes place. Parameters r a bsl :: dynarray to transfer ownership from. Return Not applicable Contracts Expects None Ensures r . empty () == true Usage 1 2 3 auto a1 = bsl :: dynarray int ( new int [ 1 ], 1 ); auto a2 = bsl :: dynarray int ( new int [ 1 ], 1 ); a2 = std :: move ( a1 );","title":"Move assignment"},{"location":"contributing/","text":"TBD","title":"Contributing"},{"location":"examples/","text":"Examples The Bareflank Support Library provides some simple examples to demonstrate how to use the library. For a more complete understanding, please read the APIs documentation or take a look at the project's unit tests. Dynamic Array The BSL provides a new container type called the Dynamic Array or bsl :: dynarray . The dynarray is the combination of a std :: unique_ptr [] array type, a std :: array , and a gsl :: span . The goal of this type to provide an array type that owns the memory associated with the array, while at the same time, providing a C++ Core Guideline compliant interface for working with the array, something that std :: unique_ptr does not provide currently. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION #include bsl.h auto main () - int { try { auto da = bsl :: make_dynarray int ( 5 ); da [ 0 ] = 4 ; da [ 1 ] = 8 ; da [ 2 ] = 15 ; da [ 3 ] = 16 ; da [ 4 ] = 23 ; da [ 5 ] = 42 ; // -- throws } catch ( const std :: exception e ) { std :: cout error: e . what () \\n ; } } The two #define statements tells the BSL to ensure the BSL is guideline compliant (as this support can be disabled to improve performance if guideline compliance is not a concern), as well as to throw an exception if a contract violation occurs. By default, contract violations are ignored, but you can also configure them to terminate if desired. The bsl :: make_dynarray () function behaves the same as std :: make_unique () without the addition of [] , creating a bsl :: dynarray of a given size. Once a bsl :: dynarray is created, you can access it using the same APIs that a std :: array and gsl :: span provide. Since guideline compliance is enabled and told to throw on violations, the attempt to set the 6 th element in the array generates an exception. Input File Array The bsl :: ifarray is a bsl :: dynarray that maps a file given a file name. Like the std :: ifstream , the bsl :: ifarray unmaps the file once it loses scope. 1 2 3 4 5 6 7 8 9 10 11 #include bsl.h auto main () - int { for ( const auto c : bsl :: ifarray char ( FILENAME )) { std :: cout c ; } std :: cout \\n ; } Since the bsl :: dynarray provides a full implementation of a random access iterator, ranged for loops can be used to safely traverse the array as shown above.","title":"Examples"},{"location":"examples/#examples","text":"The Bareflank Support Library provides some simple examples to demonstrate how to use the library. For a more complete understanding, please read the APIs documentation or take a look at the project's unit tests.","title":"Examples"},{"location":"examples/#dynamic-array","text":"The BSL provides a new container type called the Dynamic Array or bsl :: dynarray . The dynarray is the combination of a std :: unique_ptr [] array type, a std :: array , and a gsl :: span . The goal of this type to provide an array type that owns the memory associated with the array, while at the same time, providing a C++ Core Guideline compliant interface for working with the array, something that std :: unique_ptr does not provide currently. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define BAREFLANK_CORE_GUIDELINE_COMPLIANT #define BAREFLANK_THROW_ON_CONTRACT_VIOLATION #include bsl.h auto main () - int { try { auto da = bsl :: make_dynarray int ( 5 ); da [ 0 ] = 4 ; da [ 1 ] = 8 ; da [ 2 ] = 15 ; da [ 3 ] = 16 ; da [ 4 ] = 23 ; da [ 5 ] = 42 ; // -- throws } catch ( const std :: exception e ) { std :: cout error: e . what () \\n ; } } The two #define statements tells the BSL to ensure the BSL is guideline compliant (as this support can be disabled to improve performance if guideline compliance is not a concern), as well as to throw an exception if a contract violation occurs. By default, contract violations are ignored, but you can also configure them to terminate if desired. The bsl :: make_dynarray () function behaves the same as std :: make_unique () without the addition of [] , creating a bsl :: dynarray of a given size. Once a bsl :: dynarray is created, you can access it using the same APIs that a std :: array and gsl :: span provide. Since guideline compliance is enabled and told to throw on violations, the attempt to set the 6 th element in the array generates an exception.","title":"Dynamic Array"},{"location":"examples/#input-file-array","text":"The bsl :: ifarray is a bsl :: dynarray that maps a file given a file name. Like the std :: ifstream , the bsl :: ifarray unmaps the file once it loses scope. 1 2 3 4 5 6 7 8 9 10 11 #include bsl.h auto main () - int { for ( const auto c : bsl :: ifarray char ( FILENAME )) { std :: cout c ; } std :: cout \\n ; } Since the bsl :: dynarray provides a full implementation of a random access iterator, ranged for loops can be used to safely traverse the array as shown above.","title":"Input File Array"},{"location":"getting_started/","text":"Getting Started The Bareflank Support Library is a header only library, and as such, usage of this library is as simple as downloading and including the bsl . h header. Alternatively, this library support the use of find_package () and traditional installs. Installation To install the BSL onto your local system, run the following from a bash terminal to download the latest source code from GitHub: 1 2 git clone https://github.com/bareflank/bsl cd bsl Once you have the latest source code, the following can be run to perform an install: 1 2 cmake . sudo make install Alternatively, you can install the BSL into a custom prefix as follows: 1 2 cmake . -DCMAKE_INSTALL_PREFIX = prefix path sudo make install Usage The easiest way to use the BSL is to simply include it as follows: 1 #include path/bsl.h If the BSL is installed onto your local system or a custom prefix, you can use the BSL as the following: 1 #include bsl/bsl.h Finally, once compiled, you can use find_package () with CMake as follows: 1 2 3 4 5 6 7 8 cmake_minimum_required ( VERSION 3.13 ) project ( dynarray CXX ) find_package ( bsl ) set ( CMAKE_CXX_STANDARD 17 ) add_executable ( a.out main.cpp ) target_link_libraries ( a.out PRIVATE bsl ) And then include the BSL as follows: 1 #include bsl.h Compilation Options The BSL comes with both a set of examples as well as unit tests. By default, these are both built when running make . If you wish, you can turn these off as follows: 1 cmake . -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF By default, the tests and examples are built using Clang Tidy to ensure the BSL is statically analyzed during development. This too can be disabled using the following: 1 cmake . -DDISABLE_CLANG_TIDY = ON Dynamic analysis using Google's sanitizers can be enabled as follows: 1 cmake . -DCMAKE_BUILD_TYPE = ASAN or 1 cmake . -DCMAKE_BUILD_TYPE = UBSAN Build Targets In addition to the typical build targets that CMake already provides, the BSL also provides targets to format the source code as well as execute the provided unit tests if BUILD_TESTS=ON . To format the source code, Clang Format 8 or higher must be installed to execute the following 1 make format To run the unit tests, execute the following: 1 make unittests","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"The Bareflank Support Library is a header only library, and as such, usage of this library is as simple as downloading and including the bsl . h header. Alternatively, this library support the use of find_package () and traditional installs.","title":"Getting Started"},{"location":"getting_started/#installation","text":"To install the BSL onto your local system, run the following from a bash terminal to download the latest source code from GitHub: 1 2 git clone https://github.com/bareflank/bsl cd bsl Once you have the latest source code, the following can be run to perform an install: 1 2 cmake . sudo make install Alternatively, you can install the BSL into a custom prefix as follows: 1 2 cmake . -DCMAKE_INSTALL_PREFIX = prefix path sudo make install","title":"Installation"},{"location":"getting_started/#usage","text":"The easiest way to use the BSL is to simply include it as follows: 1 #include path/bsl.h If the BSL is installed onto your local system or a custom prefix, you can use the BSL as the following: 1 #include bsl/bsl.h Finally, once compiled, you can use find_package () with CMake as follows: 1 2 3 4 5 6 7 8 cmake_minimum_required ( VERSION 3.13 ) project ( dynarray CXX ) find_package ( bsl ) set ( CMAKE_CXX_STANDARD 17 ) add_executable ( a.out main.cpp ) target_link_libraries ( a.out PRIVATE bsl ) And then include the BSL as follows: 1 #include bsl.h","title":"Usage"},{"location":"getting_started/#compilation-options","text":"The BSL comes with both a set of examples as well as unit tests. By default, these are both built when running make . If you wish, you can turn these off as follows: 1 cmake . -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF By default, the tests and examples are built using Clang Tidy to ensure the BSL is statically analyzed during development. This too can be disabled using the following: 1 cmake . -DDISABLE_CLANG_TIDY = ON Dynamic analysis using Google's sanitizers can be enabled as follows: 1 cmake . -DCMAKE_BUILD_TYPE = ASAN or 1 cmake . -DCMAKE_BUILD_TYPE = UBSAN","title":"Compilation Options"},{"location":"getting_started/#build-targets","text":"In addition to the typical build targets that CMake already provides, the BSL also provides targets to format the source code as well as execute the provided unit tests if BUILD_TESTS=ON . To format the source code, Clang Format 8 or higher must be installed to execute the following 1 make format To run the unit tests, execute the following: 1 make unittests","title":"Build Targets"},{"location":"help/","text":"TBD","title":"Help"},{"location":"license/","text":"License MIT License Copyright 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}